      PROGRAM    BSP_PLOT
! ************************************************************************
! *                                                                      *
! *   Program  BSP_PLOT  analyzes contents of file of site displacements *
! *   in BSPPOS format presented as a sum of an offset, linear drift,    *
! *   and an expansion over B-spline basis. Popular VLBI processing      *
! *   program Solve generates such a file from the raw listing of        *
! *   a solution using utility getpar.                                   *
! *                                                                      *
! *   BSP_PLOT generates time series of site displacements, makes their  *
! *   plots and in a case if the spine had nodes with multiplicity,      *
! *   it computes jump(s) in positions and their uncertainties.          *
! *                                                                      *
! *   Usage:                                                             *
! *                                                                      *
! *      Usage: bsp_plot bsp-file sta_nam [-uen] [-noplot]               *
! *                                                                      *
! *      bsp-file -- name of the file in BSPPOS format that has          *
! *                  estimates of site positions, velocities,            *
! *                  coefficients of B-spline expansion and their        *
! *                  covariance matrix. The file is generated by utility *
! *                  getpar.                                             *
! *                                                                      *
! *      sta-name -- station name.                                       *
! *                                                                      *
! *      -uen     -- by default plots and position jumps are computed    *
! *                  in Cartesian crust-fixed coordinate system.         *
! *                  When this option is set, then position time series  *
! *                  and discontinuities are computed in local           *
! *                  topocentric coordinates system: Up, East, and North.*
! *                                                                      *
! *      -noplot  -- this option disables plotting. Only the amount in   *
! *                  position discontinuity(ies) is printed.             *
! *                                                                      *
! *  ### 08-MAR-2005     SPL_POS   v2.0 (c)  L. Petrov  17-NOV-2011 ###  *
! *                                                                      *
! ************************************************************************
      IMPLICIT   NONE 
      INCLUDE   'vtd.i'
      TYPE     ( BSPPOS__TYPE ) :: BSP(VTD__M_BSP)
      CHARACTER  FILBSP*128, STA_NAM*8, STR*128
      LOGICAL*4  FL_PLOT, FL_UEN, FL_LOAD_COV
      INTEGER*4  L_BSP, J1, J2, J3, I_STA, IUER
      INTEGER*4, EXTERNAL :: GET_UNIT, ILEN, I_LEN, LINDEX, LTM_DIF
!
      FL_LOAD_COV = .TRUE.
      FL_PLOT     = .TRUE.
      FL_UEN      = .FALSE.
      IF ( IARGC() .LT. 2 ) THEN
           WRITE ( 6, '(A)' ) 'Usage: bsp_plot.e bsp-file sta_nam [-uen] [-noplot]'
           CALL EXIT ( 0 ) 
         ELSE
           CALL GETARG ( 1, FILBSP )
           CALL GETARG ( 2, STA_NAM )
           IF ( IARGC() .GE. 3 ) THEN
                CALL GETARG ( 3, STR )
                IF ( STR == '-uen' ) THEN
                     FL_UEN = .TRUE.
                   ELSE IF ( STR == '-noplot' ) THEN
                     FL_PLOT = .FALSE.
                   ELSE 
                     WRITE ( 6, * ) 'Unsupported option '//STR(1:I_LEN(STR))
                     CALL EXIT ( 1 )
                END IF
           END IF
           IF ( IARGC() .GE. 4 ) THEN
                CALL GETARG ( 4, STR )
                IF ( STR == '-uen' ) THEN
                     FL_UEN = .TRUE.
                   ELSE IF ( STR == '-noplot' ) THEN
                     FL_PLOT = .FALSE.
                   ELSE 
                     WRITE ( 6, * ) 'Unsupported option '//STR(1:I_LEN(STR))
                     CALL EXIT ( 1 )
                END IF
           END IF
      END IF
!
! --- Read and parse the file with estimates of the B-spline model
! --- of station modeion
!
      IUER = -1
      CALL VTD_READ_BSP ( FILBSP, FL_LOAD_COV, VTD__M_BSP, L_BSP, BSP, IUER )
      IF ( IUER .NE. 0 ) THEN
           CALL EXIT ( 1 )
      END IF
!
! --- Search for station name
!
      I_STA = 0
      DO 410 J1=1,L_BSP
         IF ( BSP(J1)%STATION == STA_NAM ) THEN
              I_STA = J1
         END IF
 410  CONTINUE 
      IF ( I_STA == 0 ) THEN
           IUER = -1
           CALL ERR_LOG ( 8001, IUER, 'BSP_PLOT', 'There are no '// &
     &         'parameters of non-linear motion modeled with '// &
     &         'B-spline for station '//STA_NAM(1:I_LEN(STA_NAM))// &
     &         ' in file '//FILBSP )
           CALL EXIT ( 1 )
      END IF
!
! --- Build time series, make plots and print station position
! --- discontinuity(ies)
!
      IUER = -1
      CALL  BSP_SER ( BSP(I_STA), FL_UEN, FL_PLOT, IUER )
      IF ( IUER .NE. 0 ) THEN
           CALL EXIT ( 1 )
      END IF
!
      END  PROGRAM  BSP_PLOT !#!#
!
! ------------------------------------------------------------------------
!
      SUBROUTINE BSP_SER ( BSP, FL_UEN, FL_PLOT, IUER )
! ************************************************************************
! *                                                                      *
! *   Routine BSP_SER computes the time series of station positions      *
! *   represented as a sum of a linear model and the expansion over the  *
! *   B-spline basis, makes plots and prints station position            *
! *   discontinuity(ies).                                                *
! *                                                                      *
! *  ###  26-JUL-2008    BSP_SER   v1.0 (c)  L. Petrov  07-NOV-2011 ###  *
! *                                                                      *
! ************************************************************************
      IMPLICIT   NONE 
      INCLUDE   'astro_constants.i'
      INCLUDE   'vtd.i'
      INCLUDE   'diagi.i'
      TYPE     ( BSPPOS__TYPE ) :: BSP
      TYPE     ( DIAGI_STRU ) ::  DIAGI_S
      LOGICAL*4  FL_UEN, FL_PLOT
      INTEGER*4  IUER
      INTEGER*4  MPN, MP 
      PARAMETER  ( MPN = 128, MP = VTD__M_NOD*MPN )
      REAL*8     T(MP), TARG(MP), COO(MP,6), ERR(MP,6), XYZ_TO_UEN(3,3), &
     &           COV_XYZ(3,3), COV_UEN(3,3), MAT_33(3,3), &
     &           VEC1(3), VEC2(3), EPS, EPS_ARG, T1(MP), C1(MP,3), E1(MP,3)
      REAL*8,    ALLOCATABLE :: MAT(:,:)
      PARAMETER  ( EPS     = 1.D0 )
      PARAMETER  ( EPS_ARG = 0.001D0 )
      CHARACTER  STR*32, CMP(3)*1, ZAG*128, UNIT*128
      INTEGER*4  J1, J2, J3, J4, J5, J6, J7, J8, J9, J10, J11, J12, &
     &           J13, J14, J15, J16, LP, KP, LN, KNA, KJUMP, IER
      INTEGER*4  IBST, ILST, IOST, IPST, IWST, IDEV, ICL1, ICL2, ICL3
      INTEGER*4  DIAGI_LEN
      REAL*8,    EXTERNAL :: EBSPL_VAL_R8, LIN_BSPL_SIG_R8, LIN_BSPL_COV_R8 
      CHARACTER, EXTERNAL :: MJDSEC_TO_DATE*30
!
      LP = MPN*(BSP%L_NOD-1)
      KP = 0
      LN = 0
      E1 = 1.0D-5
      DO 410 J1=1,BSP%L_NOD-1
         IF ( (BSP%TIM(J1+1) - BSP%TIM(J1)) < EPS ) GOTO 410
         DO 420 J2=1,MPN
            KP = KP + 1
            T(KP) = BSP%TIM(J1) + (J2-1)*(BSP%TIM(J1+1) - BSP%TIM(J1))/(MPN-1)
            TARG(KP) = 2000.0 + T(KP)/(86400.0D0*365.25D0)
            IF ( J2 ==   1 ) THEN 
                 T(KP) = T(KP) + EPS
                 TARG(KP) = TARG(KP) + EPS_ARG
              ELSE IF ( J2 == MPN ) THEN
                 T(KP) = T(KP) - EPS
                 TARG(KP) = TARG(KP) - EPS_ARG
            END IF
            DO 430 J3=1,3
               COO(KP,J3) = EBSPL_VAL_R8 ( BSP%L_NOD, BSP%L_DEG, T(KP), &
     &                                     BSP%TIM(1), BSP%SPL(1-BSP%L_DEG,J3) )* &
     &                      1.0D3
               ERR(KP,J3) = LIN_BSPL_SIG_R8 ( BSP%L_NOD, BSP%L_DEG, T(KP), &
     &                                        BSP%TIM_REF, BSP%TIM(1), &
     &                                        BSP%COV(1-BSP%L_DEG,1-BSP%L_DEG,J3,J3) )*1.0D3
               VEC1(J3) = COO(KP,J3)
 430        CONTINUE 
            IF ( FL_UEN ) THEN
                 IF ( KP == 1 ) THEN
                      CALL MAKE_XYZ_TO_UEN  ( BSP%COO, XYZ_TO_UEN )
                 END IF
                 DO 440 J4=1,3
                    DO 450 J5=1,3
                       COV_XYZ(J4,J5) = LIN_BSPL_COV_R8 ( BSP%L_NOD, BSP%L_DEG, &
     &                                      T(KP), T(KP), BSP%TIM_REF, &
     &                                      BSP%TIM(1), &
     &                                      BSP%COV(1-BSP%L_DEG,1-BSP%L_DEG,J4,J5) ) 
 450                CONTINUE 
 440             CONTINUE 
                 CALL MUL_MM_II_I ( 3, 3, XYZ_TO_UEN, 3, 3, COV_XYZ, &
     &                              3, 3, MAT_33, -2 )
                 CALL MUL_MM_IT_I ( 3, 3, MAT_33, 3, 3, XYZ_TO_UEN, &
     &                              3, 3, COV_UEN, -2 )
                 CALL MUL_MV_IV_V ( 3, 3, XYZ_TO_UEN, 3, VEC1, 3, VEC2, -2 )
                 DO 460 J6=1,3
                    ERR(KP,J6) = DSQRT ( COV_UEN(J6,J6) )*1.D3
                    COO(KP,J6) = VEC2(J6)
 460             CONTINUE 
            END IF
            IF ( J2 == 1 .OR. J2 == MPN ) THEN
                 LN = LN + 1
                 T1(LN) = TARG(KP) 
                 C1(LN,1) = COO(KP,1)
                 C1(LN,2) = COO(KP,2)
                 C1(LN,3) = COO(KP,3)
            END IF
 420     CONTINUE 
 410  CONTINUE 
!
      IF ( FL_UEN ) THEN
           CMP(1) = 'U'
           CMP(2) = 'E'
           CMP(3) = 'N'
         ELSE 
           CMP(1) = 'X'
           CMP(2) = 'Y'
           CMP(3) = 'Z'
      END IF
!
      KJUMP = 0
      DO 470 J7=2,BSP%L_NOD-1
         KNA = 0
         DO 480 J8=J7+1,BSP%L_NOD
            IF ( BSP%TIM(J8) - BSP%TIM(J7) < EPS ) THEN
                 KNA = J8
            END IF
 480     CONTINUE 
         IF ( BSP%TIM(J7) - BSP%TIM(J7-1) < EPS ) THEN
              KNA = 0
         END IF
         IF ( BSP%L_DEG == 0 ) KNA = J7+1
!
         IF ( KNA > 0 ) THEN
              DO 490 J9=1,3
                 VEC1(J9) = EBSPL_VAL_R8 ( BSP%L_NOD, BSP%L_DEG, BSP%TIM(J7)+EPS, &
     &                                     BSP%TIM(1), BSP%SPL(1-BSP%L_DEG,J9) )
                 VEC1(J9) = VEC1(J9) - &
     &                      EBSPL_VAL_R8 ( BSP%L_NOD, BSP%L_DEG, BSP%TIM(J7)-EPS, &
     &                                     BSP%TIM(1), BSP%SPL(1-BSP%L_DEG,J9) )
 490          CONTINUE 
!
              DO 4100 J10=1,3
                 DO 4110 J11=1,3
                    COV_XYZ(J10,J11) = LIN_BSPL_COV_R8 ( BSP%L_NOD, BSP%L_DEG, &
     &                                     BSP%TIM(J7)-EPS, BSP%TIM(J7)+EPS, &
     &                                     BSP%TIM_REF, BSP%TIM(1), &
     &                                     BSP%COV(1-BSP%L_DEG,1-BSP%L_DEG,J10,J11) ) 
 4110            CONTINUE 
 4100         CONTINUE 
              KJUMP = KJUMP + 1
              IER = -1
              STR = MJDSEC_TO_DATE ( J2000__MJD, 43200.0D0 + BSP%TIM(J7), IER )
              WRITE ( 6, 110 ) KJUMP, BSP%STATION, STR(1:16)
 110          FORMAT ( 'Discontinuity #', I1, ' for station ', A, &
     &                 ' at epoch ', A )
              IF ( FL_UEN ) THEN
                   CALL MAKE_XYZ_TO_UEN  ( BSP%COO, XYZ_TO_UEN )
                   CALL MUL_MM_II_I ( 3, 3, XYZ_TO_UEN, 3, 3, COV_XYZ, &
     &                                3, 3, MAT_33, -2 )
                   CALL MUL_MM_IT_I ( 3, 3, MAT_33, 3, 3, XYZ_TO_UEN, &
     &                                3, 3, COV_UEN, -2 )
                   CALL MUL_MV_IV_V ( 3, 3, XYZ_TO_UEN, 3, VEC1, 3, VEC2, -2 )
                   DO 4120 J12=1,3
                      if ( COV_UEN(J12,J12) < 0.0 ) then
                           write ( 6, * ) 'WARNING: COVARIANCE IS WRONG!!!'
                           COV_UEN(J12,J12) = - COV_UEN(J12,J12) 
                      end if
                      WRITE ( 6, 120 ) BSP%STATION, CMP(J12), VEC2(J12)*1.D3, &
     &                                 DSQRT ( COV_UEN(J12,J12) )*1.D3
  120                 FORMAT ( 2X, A, 2X, A, '-coord   ', &
     &                         F8.1, ' -+ ', F4.1, ' mm ' )
 4120              CONTINUE 
                 ELSE 
                   DO 4130 J13=1,3
                      WRITE ( 6, 120 ) BSP%STATION, CMP(J13), VEC1(J13)*1.D3, &
     &                                 DSQRT ( COV_XYZ(J13,J13) )*1.D3
 4130              CONTINUE 
              END IF
         END IF
 470  CONTINUE 
      IF ( FL_PLOT ) THEN
           CALL DIAGI_DEF ( IBST, ILST, IOST, IPST, IWST, IDEV, ZAG, &
     &                      UNIT, ICL1, ICL2, ICL3, IER )
           DO 4160 J16=1,3
              CALL DIAGI_SETDEF ( IER, 'DIAGI_CTIT', 'Station '//BSP%STATION// &
     &                            '  '//CMP(J16)//'-coordinate (mm)' )
              CALL DIAGI_SETDEF ( IER, 'DIAGI_UNIT', 'Time (years)' )
              CALL DIAGI_SETDEF ( IER, 'DIAGI_ILST', 2 )
              CALL DIAGI_SETDEF ( IER, 'DIAGI_IBST', 4 )
              CALL DIAGI_SETDEF ( IER, 'DIAGI_IWST', 3 )
              CALL DIAGI_SETDEF ( IER, 'DIAGI_IPST', 1 )
              IER = -1
!@              CALL DIAGI_2E ( KP, TARG, COO(1,J16), ERR(1,J16), &
!@     &                        LN, T1, C1(1,J16), E1(1,J16), IER )
!
! ----------- Clear DIAGI_S object
!
              DIAGI_LEN = LOC(DIAGI_S%STATUS) - LOC(DIAGI_S%IFIRST_FIELD) + 4
              CALL NOUT ( DIAGI_LEN, DIAGI_S )
!
! ----------- Setting up the values of the DIAGI internal data structure for the further
! ----------- plotting
!
              DIAGI_S%IDEV      = IDEV
              DIAGI_S%NCLR      = 2
              DIAGI_S%NPOI(1)   = KP
              DIAGI_S%ADR_X8(1) = LOC(TARG)
              DIAGI_S%ADR_Y8(1) = LOC(COO(1,J16))
              DIAGI_S%ADR_E8(1) = LOC(ERR(1,J16))
              DIAGI_S%LER(1)    = .TRUE.
              DIAGI_S%ICOL(1)   = 1
              DIAGI_S%IBST(1)   = 4
              DIAGI_S%ILST(1)   = 2
              DIAGI_S%IOST(1)   = 1
              DIAGI_S%IPST(1)   = 1
              DIAGI_S%IWST(1)   = 2
!
              DIAGI_S%NPOI(2)   = LN
              DIAGI_S%ADR_X8(2) = LOC(T1)
              DIAGI_S%ADR_Y8(2) = LOC(C1(1,J16))
              DIAGI_S%ADR_E8(2) = LOC(E1(1,J16))
              DIAGI_S%LER(2)    = .TRUE.
              DIAGI_S%ICOL(2)   = 1
              DIAGI_S%IBST(2)   = 1
              DIAGI_S%ILST(2)   = 1
              DIAGI_S%IOST(2)   = 1
              DIAGI_S%IPST(2)   = 3
              DIAGI_S%IWST(2)   = 1
!
              DIAGI_S%ICLR      = 2
              DIAGI_S%XMIN      = 1.0
              DIAGI_S%XMAX      = 0.0
              DIAGI_S%YMIN      = 1.0
              DIAGI_S%YMAX      = 0.0
              DIAGI_S%ZAG       = 'Station '//BSP%STATION// &
     &                            '  '//CMP(J16)//'-coordinate (mm)' 
              DIAGI_S%NAME      = BSP%STATION//'_'//CMP(J16)//'-coor'
              DIAGI_S%ARG_UNITS = 'Time (years)' 
              DIAGI_S%ITRM      = 0
              DIAGI_S%IBATCH    = 0
              DIAGI_S%STATUS    = DIA__DEF
!
! ----------- Calling the main routine of DiaGI
!
              IER = -1
              CALL DIAGI     ( DIAGI_S, IER )
 4160       CONTINUE 
      END IF
!
      CALL ERR_LOG ( 0, IUER )
      RETURN
      END  SUBROUTINE  BSP_SER  !#!  
!
! ------------------------------------------------------------------------
!
      FUNCTION EBSPL_SIG_R8 ( MN, DEG, ARG, ARG_VEC, BCOE_VEC, BCOE_COV )
! ************************************************************************
! *                                                                      *
! *   Routine  EBSPL_VAL_R8  computes the uncertainty of a function      *
! *   represented as an expansion over the B-spline basis at point with  *
! *   argument ARG using coefficients of its expansion.
! *                                                                      *
! * _________________________ Input parameters: ________________________ *
! *                                                                      *
! *       MN ( INTEGER*4 ) -- The number of knots of the B-spline.       *
! *      DEG ( INTEGER*4 ) -- Degree of B-spline.                        *
! *      ARG ( REAL*8    ) -- Argument for which the function is         *
! *                           computed.
! *  ARG_VEC ( REAL*8    ) -- Array of arguments for B-spline at knots.  *
! *                           Dimension: [1:MN].                         *
! * BCOE_VEC ( REAL*8    ) -- Array of B-spline coefficients.            *
! *                           Dimension: [1-DEG:MN-1].                   *
! * BCOE_COV ( REAL*8    ) -- Elemets of the covariance matrix of 
! *                           B-spline coefficient estimates.            *
! *                           Dimension: [1-DEG:MN-1]
! *                                                                      *
! * _________________________ Output parameters: _______________________ *
! *                                                                      *
! * <EBSPL_VAL_R8> ( REAL*8    ) -- value of the function computed using *
! *                                 its expansion over B-spline basis.   *
! *                                                                      *
! *  ### 25-MAR-2010  EBSPL_VAL_R8  v1.0 (c)  L. Petrov 25-MAR-2010 ###  *
! *                                                                      *
! ************************************************************************
      IMPLICIT   NONE 
      REAL*8     EBSPL_SIG_R8 
      INTEGER*4  MN, DEG
      REAL*8     ARG, ARG_VEC(MN), BCOE_VEC(1-DEG:MN-1), &
     &           BCOE_COV(1-DEG:MN-1,1-DEG:MN-1)
      INTEGER*4  J1, J2, IP
      REAL*8,    EXTERNAL :: BSPL_VAL 
      INTEGER*4, EXTERNAL :: IXMN8 
!
      EBSPL_SIG_R8 = 0.0D0
      IF ( ARG < ARG_VEC(1)  .OR.  ARG > ARG_VEC(MN) ) THEN
!
! -------- If the argument is away from the the interpolation range,
! -------- nothing to do: its value is zero.
!
           RETURN 
      END IF
      IP = IXMN8 ( MN, ARG_VEC, ARG )
      IF ( IP < 1    ) IP = 1 
      IF ( IP > MN-1 ) IP = MN-1
      DO 410 J1=0,DEG
         DO 420 J2=0,DEG
            EBSPL_SIG_R8 = EBSPL_SIG_R8 + &
     &                     BCOE_VEC(IP-J1) * BSPL_VAL ( MN, ARG_VEC, DEG, IP-J1, ARG )* &
     &                     BCOE_VEC(IP-J2) * BSPL_VAL ( MN, ARG_VEC, DEG, IP-J2, ARG )* &
     &                     BCOE_COV(IP-1,IP-2)
 420     CONTINUE 
 410  CONTINUE 
      IF ( EBSPL_SIG_R8 >  0.0 ) THEN
           EBSPL_SIG_R8 = DSQRT ( EBSPL_SIG_R8 )
         ELSE 
           EBSPL_SIG_R8 = 0.0D0
      END IF
      RETURN
      END  FUNCTION EBSPL_SIG_R8  !#!#
!
! ------------------------------------------------------------------------
!
      FUNCTION LIN_BSPL_SIG_R8 ( MN, DEG, ARG, TIM_REF, ARG_VEC, BCOE_COV )
! ************************************************************************
! *                                                                      *
! *   Routine  EBSPL_VAL_R8  computes the uncertainty of a function      *
! *   represented as an expansion over the B-spline basis at point with  *
! *   argument ARG using coefficients of its expansion.
! *                                                                      *
! * _________________________ Input parameters: ________________________ *
! *                                                                      *
! *       MN ( INTEGER*4 ) -- The number of knots of the B-spline.       *
! *      DEG ( INTEGER*4 ) -- Degree of B-spline.                        *
! *      ARG ( REAL*8    ) -- Argument for which the function is         *
! *                           computed.
! *  ARG_VEC ( REAL*8    ) -- Array of arguments for B-spline at knots.  *
! *                           Dimension: [1:MN].                         *
! * BCOE_VEC ( REAL*8    ) -- Array of B-spline coefficients.            *
! *                           Dimension: [1-DEG:MN-1].                   *
! * BCOE_COV ( REAL*8    ) -- Elemets of the covariance matrix of        *
! *                           B-spline coefficient estimates.            *
! *                           Dimension: [1-DEG:MN+1,1-DEG:MN+1]         *
! *                                                                      *
! * _________________________ Output parameters: _______________________ *
! *                                                                      *
! * <EBSPL_VAL_R8> ( REAL*8    ) -- value of the function computed using *
! *                                 its expansion over B-spline basis.   *
! *                                                                      *
! * ### 25-MAR-2010  LIN_BSPL_SIG_R8  v1.1 (c) L. Petrov 16-NOV-2011 ### *
! *                                                                      *
! ************************************************************************
      IMPLICIT   NONE 
      REAL*8     LIN_BSPL_SIG_R8
      INTEGER*4  MN, DEG
      REAL*8     ARG, TIM_REF, ARG_VEC(MN), BCOE_COV(1-DEG:MN+1,1-DEG:MN+1)
      REAL*8     VEL_SCL, MAT_SCL
      REAL*8,    ALLOCATABLE :: COV(:,:), VEC(:)
      INTEGER*4  J1, J2, J3, J4, IND1, IND2, IP
      REAL*8,    EXTERNAL :: BSPL_VAL 
      INTEGER*4, EXTERNAL :: IXMN8 
!
      LIN_BSPL_SIG_R8 = 0.0D0
      IF ( ARG < ARG_VEC(1)  .OR.  ARG > ARG_VEC(MN) ) THEN
!
! -------- If the argument is away from the the interpolation range,
! -------- nothing to do: its value is zero.
!
           RETURN 
      END IF
      IP = IXMN8 ( MN, ARG_VEC, ARG )
      IF ( IP < 1    ) IP = 1 
      IF ( IP > MN-1 ) IP = MN-1
      VEL_SCL = 1.0D0/(ARG_VEC(MN) - ARG_VEC(1))
      ALLOCATE ( COV(0:DEG+2,0:DEG+2) )
      ALLOCATE ( VEC(0:DEG+2) )
      DO 410 J1=0,DEG+2
         IF ( J1 .LE. DEG ) THEN
              VEC(J1) = BSPL_VAL ( MN, ARG_VEC, DEG, IP-J1, ARG )
              IND1 = IP-J1
              MAT_SCL = 1.0D0
            ELSE IF ( J1 == DEG+1 ) THEN
              IND1 = MN
              VEC(J1) = 1.0D0
              MAT_SCL = 1.0D0
            ELSE IF ( J1 == DEG+2 ) THEN
              IND1 = MN+1
              VEC(J1) = (ARG - TIM_REF)*VEL_SCL
              MAT_SCL = VEL_SCL
         END IF
         DO 420 J2=0,DEG+2
            IF ( J2 .LE. DEG ) THEN
                 IND2 = IP - J2
              ELSE IF ( J2 == DEG+1 ) THEN
                 IND2 = MN
              ELSE IF ( J2 == DEG+2 ) THEN
                 IND2 = MN+1
                 MAT_SCL = MAT_SCL * VEL_SCL
            END IF
            COV(J1,J2) = BCOE_COV(IND1,IND2) * MAT_SCL
 420     CONTINUE 
 410  CONTINUE 
      LIN_BSPL_SIG_R8  = 0.0D0
      DO 430 J3=0,DEG+2
         DO 440 J4=0,DEG+2
            LIN_BSPL_SIG_R8 = LIN_BSPL_SIG_R8 + COV(J3,J4)*VEC(J3)*VEC(J4)
 440     CONTINUE 
 430  CONTINUE 
      DEALLOCATE ( COV )
      DEALLOCATE ( VEC )
!
      IF ( LIN_BSPL_SIG_R8  > 0.0D0 ) THEN
           LIN_BSPL_SIG_R8 = DSQRT ( LIN_BSPL_SIG_R8 )
         ELSE 
           LIN_BSPL_SIG_R8 = 0.0D0
      END IF
!      
      RETURN
      END  FUNCTION  LIN_BSPL_SIG_R8  !#!#
!
! ------------------------------------------------------------------------
!
      FUNCTION LIN_BSPL_COV_R8 ( MN, DEG, ARG1, ARG2, TIM_REF, ARG_VEC, &
     &                           BCOE_COV )
! ************************************************************************
! *                                                                      *
! *   Routine  LIN_BSPL_COV_R8 computes the covariance of a function     *
! *   represented as a sumn of free term, linear drift and the expansion *
! *   over B-spline basis over points with arguments ARG1 and ARG2       *
! *   using coefficients the covariance matrix of the function           *
! *   expansion.                                                         *
! *                                                                      *
! * _________________________ Input parameters: ________________________ *
! *                                                                      *
! *       MN ( INTEGER*4 ) -- The number of knots of the B-spline.       *
! *      DEG ( INTEGER*4 ) -- Degree of B-spline.                        *
! *     ARG1 ( REAL*8    ) -- Argument for which the function is         *
! *                           computed.
! *  ARG_VEC ( REAL*8    ) -- Array of arguments for B-spline at knots.  *
! *                           Dimension: [1:MN].                         *
! * BCOE_COV ( REAL*8    ) -- Elemets of the covariance matrix of        *
! *                           B-spline coefficient estimates.            *
! *                           Dimension: [1-DEG:MN+1,1-DEG:MN+1]         *
! *                                                                      *
! *                           Order of the coeeficients:                 *
! *                           1-DEG:MN-1 -- B-spline coefficients        *
! *                           MN         -- free term                    *
! *                           MN+1       -- linear drift term            *
! *                                                                      *
! *                                                                      *
! * _________________________ Output parameters: _______________________ *
! *                                                                      *
! * <EBSPL_VAL_R8> ( REAL*8    ) -- value of the function computed using *
! *                                 its expansion over B-spline basis.   *
! *                                                                      *
! * ### 16-NOV-2011 LIN_BSPL_COV_R8 v1.0 (c)  L. Petrov 16-NOV-2011 ###  *
! *                                                                      *
! ************************************************************************
      IMPLICIT   NONE 
      REAL*8     LIN_BSPL_COV_R8
      INTEGER*4  MN, DEG
      REAL*8     ARG1, ARG2, TIM_REF, ARG_VEC(MN), &
     &           BCOE_COV(1-DEG:MN+1,1-DEG:MN+1)
      REAL*8     VEL_SCL, MAT_SCL
      REAL*8,    ALLOCATABLE :: COV(:,:), VEC1(:), VEC2(:)
      INTEGER*4  J1, J2, J3, J4, IND1, IND2, IP1, IP2
      REAL*8,    EXTERNAL :: BSPL_VAL 
      INTEGER*4, EXTERNAL :: IXMN8 
!
      LIN_BSPL_COV_R8 = 0.0D0
      IF ( ARG1 < ARG_VEC(1)  .OR.  ARG1 > ARG_VEC(MN)  .OR.  &
     &     ARG1 < ARG_VEC(1)  .OR.  ARG1 > ARG_VEC(MN)        ) THEN
!
! -------- If the argument is away from the the interpolation range,
! -------- nothing to do: its value is zero.
!
           RETURN 
      END IF
!
      IP1 = IXMN8 ( MN, ARG_VEC, ARG1 )
      IF ( IP1 < 1    ) IP1 = 1 
      IF ( IP1 > MN-1 ) IP1 = MN-1
!
      IP2 = IXMN8 ( MN, ARG_VEC, ARG2 )
      IF ( IP2 < 1    ) IP2 = 1 
      IF ( IP2 > MN-1 ) IP2 = MN-1
!
      VEL_SCL = 1.0D0/(ARG_VEC(MN) - ARG_VEC(1))
!
      ALLOCATE ( COV(0:DEG+2,0:DEG+2) )
      ALLOCATE ( VEC1(0:DEG+2) )
      ALLOCATE ( VEC2(0:DEG+2) )
!
      DO 410 J1=0,DEG+2
         IF ( J1 .LE. DEG ) THEN
              VEC1(J1) = BSPL_VAL ( MN, ARG_VEC, DEG, IP1-J1, ARG1 )
              IND1 = IP1 - J1
              MAT_SCL = 1.0D0
            ELSE IF ( J1 == DEG+1 ) THEN
              IND1 = MN
              VEC1(J1) = 1.0D0
              MAT_SCL = 1.0D0
            ELSE IF ( J1 == DEG+2 ) THEN
              IND1 = MN+1
              VEC1(J1) = (ARG1 - TIM_REF)*VEL_SCL
              MAT_SCL = VEL_SCL
         END IF
         DO 420 J2=0,DEG+2
            IF ( J2 .LE. DEG ) THEN
                 VEC2(J2) = BSPL_VAL ( MN, ARG_VEC, DEG, IP2-J2, ARG2 )
                 IND2 = IP2 - J2
              ELSE IF ( J2 == DEG+1 ) THEN
                  VEC2(J2) = 1.0D0
                 IND2 = MN
              ELSE IF ( J2 == DEG+2 ) THEN
                 IND2 = MN+1
                 VEC2(J2) = (ARG2 - TIM_REF)*VEL_SCL
                 MAT_SCL = MAT_SCL * VEL_SCL
            END IF
            COV(J1,J2) = BCOE_COV(IND1,IND2) * MAT_SCL
 420     CONTINUE 
 410  CONTINUE 
      LIN_BSPL_COV_R8  = 0.0D0
      DO 430 J3=0,DEG+2
         DO 440 J4=0,DEG+2
            LIN_BSPL_COV_R8 = LIN_BSPL_COV_R8 + COV(J3,J4)*VEC1(J3)*VEC2(J4)
 440     CONTINUE 
 430  CONTINUE 
      DEALLOCATE ( COV  )
      DEALLOCATE ( VEC1 )
      DEALLOCATE ( VEC2 )
!      
      RETURN
      END  FUNCTION  LIN_BSPL_COV_R8 !#!#
