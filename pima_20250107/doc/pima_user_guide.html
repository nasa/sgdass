<HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<!-- Created by L. Petrov 2012.06.27_17:18:02 -->
<HTML lang="en">
<HEAD>
    <META HTTP-EQUIV="Content-Type" content="text/html; charset=iso-8859-1" >
    <META NAME="GENERATOR" CONTENT="manually" >
    <META NAME="Author" CONTENT="Leonid Petrov" >

    <STYLE TYPE="text/css">
    .com{
         color: 0B0B55;
           font-generic-family: "fantasy";
           font-style: normal;
           font-weight: bold;
    } 
    .wrap{
         color: 0B550B;
           font-generic-family: "fantasy";
           font-style: normal;
           font-weight: bold;
           text-shadow: 2px -2px 2px #DDDDDD;
    } 
    .val{
         color: 550B0B;
           font-generic-family: "fantasy";
           font-style: normal;
           font-weight: bold;
    } 

    .manual{
         color: 550B0B;
           font-generic-family: "fantasy";
           font-style: italic;
           font-weight: bold;
    } 

    .automatic{
         color: 0B0B55;
           font-generic-family: "fantasy";
           font-style: italic;
           font-weight: bold;
    } 

    .task{
         color: 350b55;
           font-generic-family: sans-serif;
           font-weight: bold;
<!--           
           letter-spacing: -1px; 
-->
    } 
    .pima{
         color: 0B550B;
         font-weight: bold;
         font-family: "URW Chancery L", "URW Chancery L Bold", 
                      "Comic Sans MS", "Century Gothic", 
                      CenturyGothic, AppleGothic, sans-serif;
         text-shadow: 2px -2px 2px #DDDDDD;
         font-size: 125%;
         line-height: 80%;
    } 
    .pima_font{
         font-weight: bold;
         font-family: "Comic Sans MS", "URW Chancery L";
         font-size: 125%;
    } 
   </STYLE>
    <TITLE> 
            PIMA User Guide
    </TITLE>

</HEAD>
<BODY>

<H1> <CENTER> <EM class="pima_font">PIMA</EM> User Guide </CENTER></H1>

<P><DIV ALIGN="right">
Date of last modification: <TT> 
2024.05.13_15:09:46
</TT></DIV><P>

<BLOCKQUOTE><I>   
     This document describes how to use software <EM class="pima">PIMA</EM> 
for processing VLBI visibility data. PIMA performs data calibration, fringe 
fitting, and exporting results of fringe fitting in the form that can be 
digested by VTD/Post-Solve and Difmap software for astrometry/geodesy 
analysis and for imaging.
</I>
<P>
<HR SIZE="2">
<CENTER><EM> Contents: </CENTER></EM>

<UL>
  <LI> <A HREF="#intro"> Introduction </A></LI>
  <LI> <A HREF="#prin"> Principles of <EM class="pima_font">PIMA</EM> </A></LI>
  <LI> <A HREF="#conf"> Creation of a configuration file </A></LI>
  <LI> <A HREF="#load"> Loading the data </A></LI>
  <LI> <A HREF="#logs"> Parsing log files </A></LI>
  <LI> <A HREF="#gean"> Calibrating the data </A></LI>
  <LI> <A HREF="#gepm"> Automatically generate a phase calibration mask and report of health </A></LI>
  <LI> <A HREF="#exam"> Examine raw data and calibration information </A></LI>
  <LI> <A HREF="#coarse"> Running coarse fringe fitting </A></LI>
  <LI> <A HREF="#bpas"> Computation of a complex bandpass </A></LI>
  <LI> <A HREF="#fine"> Running fine fringe fitting </A></LI>
  <LI> <A HREF="#mkdb"> Export data for astrometry/geodesy solution </A></LI>
  <LI> <A HREF="#expo"> Export data for imaging </A></LI>
  <LI> <A HREF="#gain"> Import of gain curves </A></LI>
  <LI> <A HREF="#onof"> Flagging visibilities with low amplitude at the 
                        beginning or end of a scan. </A></LI>
  <LI> <A HREF="#splt"> Running task splt for splitting and exporting data for 
                        imaging </A></LI>
  <LI> <A HREF="#gaco"> Compute gain correction </A></LI>
  <LI> <A HREF="#opag"> OPAcity Generation </A></LI>
  <LI> <A HREF="#opal"> OPAcity LOading </A></LI>
  <LI> <A HREF="#tsmo"> Compute TSys MOdel </A></LI>
  <LI> <A HREF="#splt_uc"> Use case of preparing the data suitable for 
                           imaging</A></LI>
  <LI> <A HREF="#auto_ima"> Automatic  imaging</A></LI>
  <LI> <A HREF="#samb"> Re-fringe the data using results of 
                        astrometry/geodesy solution </A>
  <LI> <A HREF="#ag_pipe"> Data analysis pipeline</A></LI>
       <UL>
           <LI> <A HREF="#fri_pipe"> Fringe fitting pipeline </A></LI>
           <LI> <A HREF="#astro_pipe"> Astrometry/geodesy pipeline</A></LI>
           <LI> <A HREF="#ima_pipe"> Imaging pipeline</A></LI>
       </UL>
       </LI>
  <LI> <A HREF="#pir"> Running the analysis pipeline with pir.py</A>
       <UL>
           <LI> <A HREF="#pir_run_levels"> pir.py run levels</A></LI>
           <LI> <A HREF="#pir_use"> Hints for pir.py use</A></LI>
       </UL>
       </LI>

  <LI> <A HREF="#dual"> Processing dual-band observations.</A></LI>
  <LI> <A HREF="#aux">  Auxiliary tools </A></LI>
       <UL>
           <LI> <A HREF="#aux_log"> Antenna log processing tool </A></LI>
           <LI> <A HREF="#aux_idi"> Tools for examining data in FITS-IDI 
                                    format </A></LI>
           <LI> <A HREF="#aux_images"> Tools for manipulation with data 
                                       in FITS image format </A></LI>
       </UL>
       </LI>
</UL>
</BLOCKQUOTE>

<HR size="1">

<A NAME="intro"> 
<H2> Introduction </H2>

<EM class="pima">PIMA</EM> is software for processing the visibilities data
from VLBI experiments. It performs data inspection,
data calibration, and fringe fitting. <EM class="pima">PIMA</EM> is designed
to process multi-source experiments that are common for
astronomical surveys and geodesy observations. <EM class="pima">PIMA</EM> has 
output interface with AIPS, DIFMAP, and VTD/Post-Solve software.

<A NAME="prin"> 
<H3> Principles of <EM class="pima">PIMA</EM> </H3>

  <EM class="pima">PIMA</EM> processes visibility data in FITS-IDI format. 
<EM CLASS="PIMA">PIMA</EM> does not transform and does modify original data. 
At the first step <EM class="pima">PIMA</EM> "loads" the data, i.e. examines 
the specified set of visibility data in FITS-IDI format and creates numerous
internal indexing tables that are written in disk. For performing all other 
operations <EM class="pima">PIMA</EM> uses these tables for getting access to
specific fields of input FITS-IDI files.
<P>

  <EM class="pima">PIMA</EM> has a flexible command-line interface and it is 
designed for a non-interactive use. <EM class="pima">PIMA</EM> is ideal for 
being incorporated into scripts for shell, python or similar interpreters.
<P>

  All control parameters that are needed for processing a given
experiment are gathered in a control file. <EM class="pima">PIMA</EM> does 
not support any defaults: all parameters, even those that are not used for 
a specific operation, are to be explicitly defined in that file.
<P>

  <EM class="pima">PIMA</EM> supports the following general syntax:
<P>
<LISTING>
pima control_file task [qualifier value...] [keyword: value...]
</LISTING>

where  
<UL> 
    <LI><TT> control_file </TT>is the name of the control file. 
         The control file contains a list of pairs keyword: value. 
         Keywords are case insensitive, values are case sensitive. 
         The order of keywords is irrelevant. If a keyword is defined 
         more than once, the last definition overrides all previous 
         definitions. The keyword defined in the command line override 
         the keywords defined in the control file.
         </LI><P>
 
    <LI><TT>task</TT> is the name of the task performed from the 
         following list:
         <P>

         <UL>
             <LI> <EM class="task">acpl</EM> &mdash; autocorrelation plotting
                  </LI><P>

             <LI> <EM class="task">acta</EM> &mdash; compute average 
                  autocorrelation spectrum 
                  </LI><P>

             <LI> <EM class="task">bmge</EM> &mdash; generate bandpass mask 
                  for visibility data 
                  </LI><P>

             <LI> <EM class="task">bpas</EM> &mdash; compute a complex bandpass
                  </LI><P>

             <LI> <EM class="task">bplt</EM> &mdash; plot bandpass
                  </LI><P>

             <LI> <EM class="task">frib</EM> &mdash; baseline fringe fitting
                  </LI><P>

             <LI> <EM class="task">frip</EM> &mdash; fringe-fitting with phase 
                  referencing 
                  </LI><P>

             <LI> <EM class="task">gean</EM> &mdash; load antenna calibration 
                  tables 
                  </LI><P>

             <LI> <EM class="task">gepm</EM> &mdash; automatically generate phase 
                  calibration mask
                  </LI><P>

             <LI> <EM class="task">load</EM> &mdash; load the FITS-IDI files and 
                  compute indexing tables 
                  </LI><P>

             <LI> <EM class="task">mkdb</EM> &mdash; make output database
                  </LI><P>

             <LI> <EM class="task">moim</EM> &mdash; import interferometric model
                  </LI><P>

             <LI> <EM class="task">mppl</EM> &mdash; plots of multiple tones of 
                   phase-cal phases and amplitudes 
                   </LI><P>

             <LI> <EM class="task">onof</EM> &mdash; determine on/off time range 
                  automatically by investing visibility data
                  </LI><P>

             <LI> <EM class="task">opag</EM> &mdash; fetch slant path delay, 
                  atmospheric opacity and atmosphere brightness temperature on 
                  an az/el grid 
                  </LI><P>

             <LI> <EM class="task">opal</EM> &mdash; load slant path delay, 
                  atmospheric opacity and atmosphere brightness temperature
                  </LI><P>

             <LI> <EM class="task">tsmo</EM> &mdash; to compute the model for
                  Tsys using decomposition of Tsys in the product of 
                  time-dependent Tsys in the zenith direction and 
                  time-independent Tsys as a function of elevation, remove
                  outliers with respect to that model, remove outliers in 
                  the ratios of Tsys with respect to different IFs and created
                  arrays of so-called modeled and cleaned Tsys for all epochs,
                  including the epochs with missing or flagged out measured 
                  Tsys.
                  
                  atmospheric opacity and atmosphere brightness temperature
                  </LI><P>

             <LI> <EM class="task">pcpl</EM> &mdash; make a plot of phase 
                  calibration signal 
                  </LI><P>

             <LI> <EM class="task">pdpl</EM> &mdash; make a plot of the phase 
                   calibration signal at the LL polarization with respect to the 
                   phase calibration signal at the RR polarization.
                  </LI><P>

             <LI> <EM class="task">pmge</EM> &mdash; generate bandpass mask for 
                  phase-cal data 
                  </LI><P>

             <LI> <EM class="task">pplt</EM> &mdash; generate polarization 
                  bandpass plot 
                  </LI><P>

             <LI> <EM class="task">prga</EM> &mdash; print gain information
                  </LI><P>

             <LI> <EM class="task">splt</EM> &mdash; split the data into sources 
                  and write output FITS-files 
                  </LI><P>

             <LI> <EM class="task">tspl</EM> &mdash; plotting the system temperature
                  </LI><P>

             <LI> <EM class="task">tst1</EM> &mdash; reserved for tests
                  </LI><P>

             <LI> <EM class="task">upgr</EM> &mdash; upgrade control file
                  </LI><P>
         </UL>

    <LI><TT>qualifier value</TT> &mdash; additional parameters 
         that are supplied to task. They are specified 
         as a pair qualifier and its value. Some tasks require more than 
         one qualifier. Many tasks do not require qualifiers. The order of 
         qualifiers is irrelevant.
         </LI><P>

    <LI><TT>keyword value</TT> &mdash; additional pairs 
         keyword: value. These pairs override definitions from the control 
         file. These pairs can be viewed as amendments of the control file
         applied on the fly. If the command line has more than one definition
         of the same keyword, the last definition takes precedence. If the 
         value of any keyword is omitted, <EM class="pima">PIMA</EM> will 
         print error message.
         </LI><P>
</UL>

  <EM class="pima">PIMA</EM> supports a number of optional kludge parameters 
that alter normal processing in a form of keyword: value. The have a prefix 
<TT>PIMAVAR_</TT>. They can be either defined in the control file or put in 
the command line, or defined as environment variables.

<H3> Frontend wrappers </H3>

  <EM class="pima">PIMA</EM> provides several frontend wrappers. They accept 
arguments, perform some operations and finally call <EM class="pima">PIMA</EM>. 
A user does not have to use wrappers. They are provided just for convenience. 
Though, using wrappers sets some restrictions on how to name 
<EM class="pima">PIMA</EM> related files. If you are going to use 
wrappers than the file name are supposed to obey the following convention:

<OL>

  <LI> Files related to a certain experiment reside in subdirectory 
       <TT>VVVVV</TT>, where <TT>VVVVV</TT> is the root directory of 
       vlbi experiments specified by --pima-exp-dir  during configuration.
       </LI><P>
  <LI> Control file has name <TT>VVVVV/EEE/EEE_B_pima.cnt</TT> where 
       <TT>B</TT> is band name in lower case. For instance, the control 
       file for band C (4.3 GHz) for  experiment bp192c0 is sought in 
       <TT>/vlbi/bp192c0/bp192c0_c_pima.cnt</TT>,  provided 
       <EM class="pima">PIMA</EM> was 
       configured with <TT>--pima-exp-dir=/vlbi</TT>. 
       </LI><P>
  <LI> Wrappers will create the following files
       <UL>
           <LI> <TT>VVVVV/EEE/EEE_load.log</TT> &ndash; log of task
                <EM class="task">load</EM> the database.
                </LI><BR>

           <LI> <TT>VVVVV/EEE/EEE_B_nobps.fri</TT> &ndash; results of 
                fringe fitting in the coarse mode.
                </LI><BR>

           <LI> <TT>VVVVV/EEE/EEE_B_coarse.log</TT> &ndash; log of fringe
                fitting in the coarse mode.
                </LI><BR>

           <LI> <TT>VVVVV/EEE/EEE_B_fine.log</TT> &ndash; log of fringe
                fitting in the fine mode.
                </LI><BR>

           <LI> <TT>VVVVV/EEE/EEE_mkdb.log</TT> &ndash; log of generation
                a database in GVF format.
                </LI><BR>

           <LI> <TT>VVVVV/EEE/EEE_splt.log</TT> &ndash; log of task 
                <EM class="task">splt</EM>. </LI><BR>

           <LI> <TT>VVVVV/EEE/EEE_B_gain.log</TT> &ndash; listing with used
                antenna gains. 
                </LI><BR>

           <LI> <TT>VVVVV/EEE/EEE_B_map.log</TT> &ndash; log of automatic
                data imaging.
                </LI><BR>
       </UL></LI><P>
</OL>

Several wrappers are provided. Among them are

<UL>
     <LI><EM class="wrap">pu.py</EM>  &ndash; Fringe fitting. Includes tasks 
         data loading, parse log files, coarse fringe fitting, bandpass 
         computation, fine fringe fitting, data calibration and slitting, 
         generation of the output database in GVF format.
         </LI><P>
     <LI><EM class="wrap">pt.py</EM>  &ndash; Trial fringe fitting. Runs 
         a trial fringe fitting procedure for a given observation.
         </LI><P>
     <LI><EM class="wrap">pr.py</EM> &ndash; Resolving sub-ambiguities. 
         Parses the listing of the VTD/Post-Solve run, generates control 
         file for re-fringing with a narrow search window, executes that
         control file, and updates the database.
         </LI><P>
</UL>

<H3> Graphic interface </H3>

     <EM class="pima">PIMA</EM> uses graphics interface DiaGI based on 
PGPLOT library. DiaGI displays plot into X-window. It allows to resize 
plot, change plot appearance, inquire a point, make a hardcopy, etc. 
Refer to DiaGI documentation for details. It is assumed in this manual 
a reader is already familiar with DiaGI interface. DiaGI documentation 
can be found here:
<A HREF="http://astrogeo.org/mk5/help/diagi_1.hlp"</A>DiaGI doc-1</A>,
<A HREF="http://astrogeo.org/mk5/help/diagi_2.hlp"</A>Diagi doc-2</A>, and
<A HREF="http://astrogeo.org/mk5/help/diagi_3.hlp"</A>Diagi doc-3</A>.


<H3> Minimalistic workflow </H3>

  The workflow of the minimalistic, simplified analysis:
<P>

<UL>
    <LI> <EM class="task">load</EM> &mdash; parses and loads the data. 
         This is always the first operation. A user is supposed to prepare 
         control file that defines the name of visibility file(s) in FITS-IDI, 
         station catalogue, source catalogue, control file for VTD, experiment
         description file, and parameters that control further analysis. 
         Results of parsing the visibility data are written in a binary file. 
         For all tasks, except  <EM class="task">load</EM>, 
         <EM class="pima">PIMA</EM> reads that file immediately after start.
         </LI><P>

     <LI><EM class="task">frib</EM> &mdash; performs coarse fringe search 
          without bandpass calibration and masking bad data. Some results of 
          this fringe search will be used for computation of bandpass 
          calibration and automatic flagging. Usually, no oversampling is 
          performed during coarse fringe search.
          </LI><P>

     <LI><EM class="task">bpas</EM> &mdash; computes the complex bandpass
          calibration and complex polarization band-pass (for dual-band data) 
          using results of the coarse fringe search.
          </LI><P>

     <LI><EM class="task">frib</EM> &mdash; performs fine fringe search with 
          bandpass calibration applied. Usually, the data are over-sampled with 
          a factor of 4.
          </LI><P>

     <LI><EM class="task">mkdb</EM> or <EM class="task">splt</EM> &mdash;  
          generate the final product of <EM class="pima">PIMA</EM> using
          results of fringe fitting: 
          <UL>
              <LI> the database with total group delays, phase delay rates 
                   and related parameters for consecutive astrometry/geodesy
                   data analysis;
                   </LI><P>

              <LI> visibilities coherently averaged over frequency and 
                   specified time intervals, with averaged visibilities
                   split into files, one file per source, in a form ready
                   for imaging analysis with DIFMAP.
                  </LI><P>
          </UL>
          </LI><P>
</UL>    
                  
<A NAME="conf"> 
<H2> Creation of a configuration file </H2>

Supported keywords are described in 
<A HREF="pima_keywords.html">pima_keywords.html</A> document. Control file 
contains lines with pairs <EM class="com">keyword:</EM> 
<EM class="com">value</EM>. Lines that start with <TT>#</TT> are considered 
as comments. The first and the last line of a control file is its label
<LISTING>
# PIMA_CONTROL file.  Format Version of 2020.04.19
</LISTING> 
<P>

  Keyword names are in upper case and are terminated by column. Values are
case sensitive. If the same keyword is defined more than once, the last 
definition takes preference. The pair keyword: value defined in the control 
file are processed as if they appended to the end of the control file. There 
are two exceptions: <EM class="com">UV_FITS</EM> and 
<EM class="com">INTMOD_FILE</EM>. More than these keywords are allowed
for a case when several input files should be defined.
<P>

Some values in <EM class="pima">PIMA</EM> control file are file names. 
Although you can define relative file names, defining absolute file names 
is encouraged.
<P>

  A user rarely creates a configuration file from scratches. Usually, 
a control file from a similar experiment is copied to a new name and 
a user edits it. A user should check carefully every keyword. The following 
keywords are the most commonly need to change:
<UL>

   <LI><EM class="com">SESS_CODE</EM> &mdash; session code. Usually, this 
       is the experiment code defined in the FITS-file. All names of output 
       files that <EM class="pima">PIMA</EM> generates will contain this code 
       inside. Therefore, this code should be unique for a given experiment. 
       You can have several trial control files for the same experiment. 
       If you want to distinguish output files generated by this trial control 
       files, you may use different <EM class="com">SESS_CODE</EM>. 
       <B>NB:</B> if you change <EM class="com">SESS_CODE</EM>, you must re-run 
       task <EM class="task">load</EM>.
       </LI><P>

   <LI><EM class="com">UV_FITS</EM> &mdash; name of FITS-files. Obviously, you 
       need to define only these FITS-files that you want to process. NB: if 
       you change the number of FITS-files or rename them, you must re-run task 
       <EM class="task">load</EM>. If you moved FITS-files to another directory 
       without change of the base name and extension, you do not have re-run 
       task <EM class="task">load</EM>. 
       <P>
 
       There may be more than one FITS-IDI file in the processed dataset.
       In that case, more than one lines with keyword <EM CLASS="COM">UV_FITS</EM> 
       should appear in the control file. FITS-IDI files should appear in the 
       chronological order.
       <P>
       
       <EM class="pima">PIMA</EM> requires that the number of spectral channels 
       within each intermediate frequency (IF) be the same for each FITS-IDI 
       file. If your experiment has different spectral resolution, 
       <EM class="pima">PIMA</EM> cannot process it as one experiment. In that 
        case you need to write more than one control file with different
       <EM class="com">SESS_CODE</EM> keyword and process then separately.

       </LI><P>

   <LI><EM class="com">SOU_NAMES</EM>  &mdash; filename with source catalogue.
       This source catalogue is used for several purposes: 
       <P>
       <UL>
           <LI> defining B1950 and J2000 source names for observed sources.
                FITS-IDI contains only one name for observed sources. 
                </LI><P>

           <LI> renaming a source. A source catalogue has four columns:
                IVS name, B1950 IAU name, J2000 IAU name and alternative
                name. The alternative name column allows to match 
                a non-standard name.
                 </LI><P>

           <LI> defining new coordinates of a source that are different
                than those used for correlation. Strictly speaking,
                position of a "source" used for correlation is a position
                of the center of the field. A source may be off the center
                of the field of view. If the source is far away from the
                center of the field, the non-liner term of phase as 
                a function of time may appear significant. 
                <EM class="pima">PIMA</EM> has an option that allows to 
                compensate this term, but it needs to know the position 
                of the source, not the center of the field.
                </LI><P>

           <LI> there may be more than one source the field of view.
                <EM class="pima">PIMA</EM> allows to "split the source": 
                to define more than one source that corresponds to the same 
                field of view. In order to split the source, put @ in column 
                32 of <I>adjacent</I> rows of the catalogues. Adjacent rows 
                should have the same alternative name defined in column 
                33:42. You may split the field of view in more than one 
                source. NB: if you split several different fields of view, 
                they should not occupy adjacent rows. Put comment line 
                between different fields of view that are spit into several 
                sources. Internally, <EM class="pima">PIMA</EM> associate 
                with each source a set of entries of the FITS-IDI file with 
                visibilities. 
                </LI><P>

           <LI> Sometimes it is desirable to swap source names of two sources.
                Character ^ at the 32th column tells <EM class="pima">PIMA</EM>  to change name of 
                the source specified in columns 33:42 to the name specified 
                in columns 1:8. It will use the a priori positions specified 
                for that sources in columns 46:73. Character ^ at the 32th 
                column is used when we want just to change source name. Using 
                character ^ at the 32th column we can even swap source names.
                If the field in the column 32 is blank and the field in 
                columns 33:42 contains a source name, <EM class="pima">PIMA</EM>  will search a record 
                with the IVS name equal to the string specified in columns 
                33:40 and it will use the a priori for that record. Blank at 
                the 32th column is used when we want associated source observed 
                under name A to a known source with name B with its a priori 
                positions.
                <P>

                The differences between these to cases:
               <UL>
                    <LI> when character ^ is used, the a priori specified at 
                         the same line are used, while if the 32th columns is 
                         blank, a priori for another matching record is used. 
                         Since <EM class="pima">PIMA</EM> applies phase 
                         correction due to difference between a priori position
                         specified in the source catalogue and the a priori 
                         used by the correlator, the result will be different.
                         </LI><P>
   
                    <LI> when character ^ is used, source name swapping is 
                         allowed, but name swapping is impossible when blank 
                         is used in field 32.
                         </LI><P>

                </UL><P>
       </UL>
       <P>

       Keep in mind that each source should be defined in two catalogues:
       one catalogue used for association with the center of fields 
       defined in FITS-IDI files. Another catalogue is used for
       computation of theoretical path delay. That catalogue is defined
       on VTD control file used by <EM class="pima">PIMA</EM>. The primary 
       source name is the "IVS name" which is B1950 name with same exception.
       Any observed source (NB: a <I>source</I>, not the field!) should 
       have a record in the source catalogue defined in the VTD control
       file that is associated with the <EM class="pima">PIMA</EM> source 
       catalogue via the field IVS source name. Internally, 
       <EM class="pima">PIMA</EM> will use IVS source names, but it also keeps 
       the original name of the center of the field.

       <P>

       If during task <EM class="task">load</EM> <EM class="pima">PIMA</EM> 
       cannot find a source name(s) in the input catalogue, it issues an error 
       message that contains names and coordinates of all missing sources at 
       the beginning of the task. If <EM class="pima">PIMA</EM> cannot find   
       a source name in VTD source catalogues, it issues an error message that 
       contains names and coordinates of all missing sources at the end of 
       the task.
       </LI><P>

   <LI><EM class="com">STA_NAMES</EM> &mdash; filename with station catalogue.
       Each station that participated in the processed VLBI experiment
       should have a record in the station catalogue. The station 
       catalogue has several columns. The first column is the name
       of the station used by the correlator. It may use up to 8 characters.
       The second column contains a standardized IVS 8-character long 
       station name. The main purpose of this station name is to match
       the station name used by the correlator and the IVS name.
       Internally, <EM class="pima">PIMA</EM> will use the IVS station name, 
       but also keeps the original name.
       </LI><P>

   <LI><EM class="com">EXPER_DIR</EM> &mdash; name of the scratch directory 
        where <EM class="pima">PIMA</EM> will write some results, including 
        intermediate files.
       </LI><P>

   <LI><EM class="com">MIN_SCAN_LEN</EM>, <EM class="com">MAX_SCAN_LEN</EM>, 
        <EM class="com">MAX_SCAN_GAP</EM> &mdash; these parameters control the 
        algorithm for splitting the  dataset into scan. Depending the goals of 
        your experiment, you may adjust the strategy for splitting the data 
        into scans.
       </LI><P>

   <LI><EM class="com">BANDPASS_FILE</EM>, 
       <EM class="com">BANDPASS_MASK_FILE</EM>, 
       <EM class="com">PCAL_MASK_FILE</EM>, 
       <EM class="com">POLARCAL_FILE</EM>, 
       <EM class="com">FRINGE_FILE</EM>, 
       <EM class="com">FRIRES_FILE</EM> &mdash; 
       obviously, these files are specific for a given experiment and should 
       have unique names. It is a good practice to keep all these files in 
       the same experiment specific directory.
       </LI><P>

   <LI><EM class="com">MKDB.OUTPUT_NAME</EM> &mdash; defines either suffix if 
       <EM class="com">MKDB.OUTPUT_TYPE</EM>: <EM class="val">GVF</EM> or the 
       file name if <EM class="com">MKDB.OUTPUT_TYPE</EM>: 
       <EM class="val">TEXT</EM>. The name should be experiment specific. If 
       more than one experiment has the nominal start time at the same day, 
       the suffix should be unique. Please check the suffix carefully. 
       Otherwise, <EM class="pima">PIMA</EM> may override existing database 
       for different experiment!
       </LI><P>

   <LI><EM class="com">EPHEMERIDES_FILE </EM> &mdash; if you process VLBI 
       experiment with RadioAstron, you need to specify the relevant ephemeride 
       file that covers the time interval of the experiment.
       </LI><P>

   <LI><EM class="com">MKDB.DESC_FILE </EM>&mdash; this file defines auxiliary 
       information specific for this experiment. You need to copy the description 
       file for similar experiment to another name and edit accordingly.
       </LI><P>

</UL> 

<A NAME="load"> 
<H2> Loading the data </H2>

  Task data loading is the first task. <EM class="pima">PIMA</EM> parses the 
control file, finds the data with visibilities in FITS-IDI format, and reads 
them. It gathers information about station names, sources names, frequencies, 
a priori models, system temperature, gain, weather information, phase 
calibration, cable calibration, etc. It reads all cross-correlations and 
auto-correlations, associates them, and checks for their consistencies. Then 
<EM class="pima">PIMA</EM> splits the data into scans and observations. 
It creates scan tables, observation tables and associates observations with 
indices of visibilities. All tables are written into a binary file 
<TT>SSSSS/EEE.pim</TT>, where <TT>SSSSS</TT> is the scratch directory 
specified in the keyword <EM class="com">EXPER_DIR</EM> and <TT>EEE</TT> is 
the experiment name specified in the keyword <EM class="com">SESS_CODE</EM> 
of the <EM class="pima">PIMA</EM> control file. Data loading takes from 20 
seconds for small experiments to 2&ndash;4 hours for experiments with 
visibility files of terabyte size. All other <EM class="pima">PIMA</EM> 
operations will read file <TT>SSSSS/EEE.pim</TT> and use indexing tables. 
Unlike to AIPS or CASA, <EM class="pima">PIMA</EM> does not rewrite input 
visibility data in its own format. Instead of it, it creates indexing tables 
and uses this tables when it needs to collect visibilities for processing 
a given observation. The advantage of this approach is that no intermediate 
files is created. The disadvantage is that reading of visibility data may 
become inefficient when if the input data file that reside on magnetic 
hard-drive are  larger than than the amount of available operative memory due 
to limitations related to a design of FITS-IDI data. <EM class="pima">PIMA</EM>
does not need input information about learning how the data are split into 
scans: it does it itself. The advantage of this approach is that 
<EM class="pima">PIMA</EM> will process the data even if any auxiliary 
information is lost. The disadvantage of this approach is that 
<EM class="pima">PIMA</EM> can split the data into scans not the same way as 
an observer designed the experiment.
<P>

  The first operation of task <EM class="task">load</EM> is parsing control 
file. VTD control file specified in <EM class="pima">PIMA</EM> control file 
is also parsed. Finally, the experiment description file specified in the 
keyword <EM class="com">MKDB.DESC_FILE</EM> is parsed. Any errors, such as 
syntax errors or files that do not exist are reported. 
<EM class="pima">PIMA</EM> will stop and issue an error message in a case 
of errors.
<P>

  In the next step <EM class="pima">PIMA</EM> will check every source name 
first in the file specified in keyword <EM class="com">SOU_NAMES</EM>, then 
in catalogue files specified in VTD control file. If it finds at least one 
source not in the catalogue, <EM class="pima">PIMA</EM> will issue the error
message and print the list of missing source names and their coordinates 
extracted from the FITS file.
<P>

  Then <EM class="pima">PIMA</EM> will check every station name first in 
the file specified in keyword <EM class="com">STA_NAMES</EM>, then in 
catalogue files specified in VTD control file. If it finds at least one 
station not in the catalogue, <EM class="pima">PIMA</EM> will issue the 
error  message and print the list of missing station names and their 
coordinates extracted from the FITS file.
<P>

  Then <EM class="pima">PIMA</EM> check frequencies in each files and creates 
the global frequency table for the entire experiment. It converts low side 
band intermediate frequencies tables (LSB IF) into upper side band IFs by
re-ordering frequencies of the channels within each IF for them to
following in the ascending order. It merges or combines frequency groups
if requested. Finally, it tables of cross indices from the original 
frequency tables frequency groups to the global frequency table,
frequency groups and vice versus.
<P>

  Next step is to read all visibility data. Visibility data are sorted,
cross-correlation data are linked to autocorrelation data, and tables
of time indices, cross-correlation indices and auto-correlation indices
are created. <EM class="pima">PIMA</EM> checks for organ visibilities: 
cross-correlation visibilities without autocorrelation and auto-correlation 
data within matching cross-correlation data. These visibilities are added 
to the list of "bad data".
<P>

 Then <EM class="pima">PIMA</EM> splits the data into scans. By that time 
the data are chronologically sorted. There are three parameters in the  
<EM class="pima">PIMA</EM> control file that controls the process of data 
splitting: <EM class="com">MIN_SCAN_LEN</EM>, 
<EM class="com">MAX_SCAN_LEN</EM>, and <EM class="com">MAX_SCAN_GAP</EM>. 
<EM class="pima">PIMA</EM> sets a preliminary scan boundary when a source 
is changed. If it does not find valid visibilities for 
<EM class="com">MAX_SCAN_GAP</EM> seconds after the last valid visibility 
of the previous source, it sets the end of scan of the previous source. 
If duration of the time from the first valid visibility of a given scan is 
longer than <EM class="com">MAX_SCAN_LEN</EM>, a border of
a scan is set, and a new scan starts. That means that a scan cannot be 
longer than <EM class="com">MAX_SCAN_LEN</EM> seconds and it cannot have 
a gap longer than <EM class="com">MAX_SCAN_GAP</EM>.
At the same time scans of different sources may overlap, i.e as  scan B may 
have start and stop time within the interval of start and stop time of the 
scan A. Scans shorter than <EM class="com">MIN_SCAN_LEN</EM> seconds are 
eliminated and the visibilities within such short scans are marked as bad.
<P>

  The choice of <EM class="com">MIN_SCAN_LEN</EM>, 
<EM class="com">MAX_SCAN_LEN</EM>, and <EM class="com">MAX_SCAN_GAP</EM> 
is determined by scheduling goals and the correlator setup. Usually 
<EM class="com">MIN_SCAN_LEN</EM> is set to have at least three 
accumulation periods, otherwise fringe fitting process may fail. For 
non-phase referencing experiment <EM class="com">MAX_SCAN_LEN</EM> can be 
set to the scan length set by the schedule. Experiments at 22 GHz and 
higher <EM class="com">MAX_SCAN_LEN</EM> can be set shorter to be close 
to the coherence time. <EM class="com">MAX_SCAN_GAP</EM> can be set to 
1/2 of the scan length to prevent scan split in a case of  data loss 
within a scan. For scan-referencing observations 
<EM class="com">MAX_SCAN_LEN</EM> is set to the cycle duration and 
<EM class="com">MAX_SCAN_GAP</EM> is set to 90% of 
<EM class="com">MAX_SCAN_LEN</EM>. It should be noted that 
<EM class="pima">PIMA</EM> allows to use a portion of a scan in data 
analysis, but it cannot unite two scans. Parameter 
<EM class="com">SCAN_LEN_USED</EM> and <EM class="com">SCAN_LEN_SKIP</EM> 
allows to set up  continuous portion of a scan for fringe fitting and 
split after <EM class="task">load</EM> task. But <EM class="pima">PIMA</EM>
cannot increase scan length after task <EM class="task">load</EM> is done. 
If a user needs to change scan allocation or increase scan length, task 
<EM class="task">load</EM> should be re-run. NB: if a new run of task 
<EM class="task">load</EM> changes the total number of observations, 
fringe  fitting should be re-run, since the stale fringe results have 
different scan and observation indices.
<P>

  After <EM class="pima">PIMA</EM> split the data into scans, it checks 
all cross- and auto- visibility data whether they are claimed by scans. 
All visibilities not claimed by scans are marked as bad.
<P>

  If <EM class="pima">PIMA</EM> finds at least one bad visibility, 
<EM CLASS="PIMA">PIMA</EM> stops withe an error message. Since getting bad 
visibilities is rather a common situation, <EM class="pima">PIMA</EM> has 
a mechanism to accommodate them.  <EM CLASS="PIMA">PIMA</EM> control file 
supports keyword <EM class="com">UV_EXCLUDE_FILE</EM> that defines a file with 
indices of visibilities, either cross or auto, that are to be excluded 
at the very beginning. These visibilities are excluded from analysis, 
and <EM class="pima">PIMA</EM> cannot mark them bad because it does not see 
them. <EM CLASS="PIMA">PIMA</EM> supports a special value of parameter 
<EM class="com">UV_EXCLUDE_FILE:</EM> <EM class="val">AUTO</EM>. If value 
<EM class="val">AUTO</EM> is specified, than when <EM class="pima">PIMA</EM> 
finds bad points, it writes visibility indices in the so-called bad visibility 
file at <TT>SSSSS/EEE_uv.exc</TT> file, where <TT>SSSSSS</TT> 
is EXPER_DIR and <TT>EEE</TT> is <EM class="com">SESS_CODE</EM>. 
If that file already exists, <EM class="pima">PIMA</EM> appends new 
visibilities to that file. When <EM class="com">UV_EXCLUDE_FILE:</EM> 
<EM class="val">AUTO</EM>, tasks <EM class="task">load</EM> is executed several 
times. The first time <EM class="pima">PIMA</EM> finds bad points, puts them in 
the <TT>SSSSS/EEE_uv.exc</TT> file and stops with the exit code 23. The second 
time the bad points in <TT>SSSSS/EEE_uv.exc</TT> are read and excluded from the 
subsequent analysis. Usually two runs are sufficient. Sometimes the 3rd and 4th 
is required. Wrapper <EM class="wrap">pf.py</EM> executes the 2nd, 3rd and 4th 
run automatically. NB: <EM class="wrap">pf.py</EM>purges 
<TT>SSSSS/EEE_uv.exc</TT> file if it exists.
<P>
   
  After splitting the data into scans, <EM class="pima">PIMA</EM> reads and 
parses phase calibration, system temperature, weather information, 
interferometric model and interferometric model components. Any these 
parameters may be missing in the FITS-IDI file. In such cases 
<EM class="pima">PIMA</EM> issues a warning, but proceeds.
<P>

  If <EM class="com">PCAL</EM>: <EM class="val">NO</EM> is specified 
in the control file, <EM class="pima">PIMA</EM> will skip phase calibration
information present in the FITS-IDI file(s). Keep in mind, if 
<EM class="com">PCAL</EM>: <EM class="val">NO</EM> was specified during 
loading, <EM class="pima">PIMA</EM> cannot re-enable phase calibration 
later within  running task <EM class="task">load</EM> again. If phase 
calibration was loaded and cane be disabled for entire experiment or for 
the specified station(s) and re-enabled again. If phase calibration is 
not available for some scans at some stations, such observations are
flagged as bad and are skipped for fringe fitting and other operations,
unless phase ca libation is disabled for the entire experiment by 
specifying <EM class="com">PCAL</EM>: <EM class="com">NO</EM> or by 
disabling pcal at both stations of the baseline of that observation. 
It should be noted that bandpass and fringe results will be different 
whether phase calibration was used or not. Therefore, if phase 
calibration status was changed, bandpass should be re-generated and 
fringe fitting re-done.
<P>
  
  Correlator organzies data by spectral channels, intermediate
frequencies (IFs) and frequency groups. Strictly speaking, 
fringe fitting can be done only within one frequency group
<EM class="pima">PIMA</EM> has two ways to circumvent this resutriction.
<P>

  If UV data from several frequency groups have the same time tag, such 
freuqnecy groups are called overlapping. Overlapping frequency groups
can be merged to a new virtual group. When task <EM class="task">load</EM> 
is executed with <EM class="com">FRQ_GRP</EM><EM class="val">: m:n</EM>, 
where <TT>m</TT> and <TT>n</TT> is a range of the frequency groups, a new 
virtual groups created that merges IFs of frequency grops from <TT>m</TT> to <TT>n</TT>. 
The number of IFs of the new virtual group is <TT>(m-n+1)*Num_IF</TT>. 
The new virtual group has index 1 and has (m-n+1)*Num_IF IFs, where 
Num_IF is the number of IFs in orginial groups. After loading either
<EM class="com">FRQ_GRP</EM><EM class="val">: m:n</EM> or 
<EM class="com">FRQ_GRP</EM><EM class="val">: 1</EM> forms can be 
specified to us the merged group. Other forms of 
<EM class="com">FRQ_GRP</EM>, such 
as <EM class="com">FRQ_GRP</EM><EM class="val">: 2</EM> are not accepted.
<P>

  If UV data from several frequency groups have the different time tag, such 
groups are not overlapping. A common usual case: change of the reciever
or the backend setup while the antennas are on source. The non-overlapping
groups can be combined into a new virtial group by involiing task 
<EM class="task">load</EM> with <EM class="com">FRQ_GRP:</EM><EM class="val"> m-n</EM>, where 
<TT>m</TT> and <TT>n</TT> is a range of the frequency groups.
The number of IFs of the new virtual group is (m-n+1)*Num_IF. The new 
virtual group has index <TT>g+1</TT>, where <TT>g</TT> and has 
<TT>(m-n+1)*Num_IF</TT> IFs, where Num_IF is the number of IFs in orginial 
groups. After loading data, the virtial group can be accessed as
<EM class="com">FRQ_GRP:</EM><EM class="val"> g+1</EM>. Other forms of 
<EM class="com">FRQ_GRP</EM>, such as 
<EM class="com">FRQ_GRP:</EM><EM class="val"> 1</EM> are not accepted.
<P>

  It is important to note that virtial frequency group are created when
running task <EM class="task">load</EM>. Just calling 
<EM class="pima">PIMA</EM> with <EM class="com">FRQ_GRP: m:n</EM> or
<EM class="com">FRQ_GRP: m-n</EM> after loading will cause an error 
message, unless the virtial frequency group has been created by task
<EM class="task">load</EM>. 
<P>

  By 2016.01.01 only VLBA put model and all calibration information into
the FITS-IDI data. Lack of calibration information does not prevent 
<EM class="pima">PIMA</EM> to run fringe fitting by may prevent further tasks. 
For instance, task <EM class="task">splt</EM> cannot run if no Tsys and/or 
antenna gains is available. Task <EM class="task">mkdb</EM> cannot run if 
the interferometric model is not available. VLBA  hardware correlator and DiFX 
version 2.0 and newer puts phase calibration information into FITS-IDI. Other 
correlators do not to do it. Missing weather information, Tsys can be loaded 
by <EM class="pima">PIMA</EM> task <EM class="task">gean</EM> using results 
of parsing log-files. Missing antenna gains can be loaded by 
<EM class="pima">PIMA</EM> task <EM class="task">gean</EM>  from external 
gain files. Missing interferometric for VERA, SFXC, and KJCC correlators can 
be loaded by task <EM class="task">moim</EM> from external model files in 
native format that were used by the correlator.  
<P>
   Example: processing an experiment correlated with SFXC (JIVE correlator).
            A user need collect all delay files and one clock files.
            The delay files and the clock file need be put either in 
            a separate directory that keeps the interferometric data for 
            this specific experiment or a tree of sub-directories. The delay
            files are in a binary format SFXC supports two formats pre-2020 
            and post-2020. <EM class="pima">PIMA</EM> recognises them 
            automatically. <EM class="com">INTMOD_FILE:</EM> keyword 
            specifies a file or a directory with delays. More than one 
            keyword <EM class="com">INTMOD_FILE:</EM> can be specified.
            <EM class="pima">PIMA</EM> will find all files with extension
            ".del", extract the apriori interferometric model, sort it
            and puts in the internal data structure. It will also search
            for a file with extension ".clk" with the clock model.
<P>
Then the <EM class="pima">PIMA</EM> control file should have these 
definitinos:

<EM class="com">INTMOD_FILE:        directory_name_with_del_files</EM><BR>
<EM class="com">INTMOD_TYPE:        SFXC</EM>

<P>
  NB: If the data are re-loaded, task <EM class="task">splt</EM> should 
be repeated.
<P>
SFXC Format description  of 2024.05.13:

<PRE>
SFXC post-2020 inteferometric model format supports adding extra 
rows of delay model before and after each scans. This makes some 
things easier in the correlator.

How many extra rows there are is controlled by a variable called
n_padding, the value of which is stored in the delay file header.
So there are n_padding extra rows before and after each scan.

Also new in the header is a version number.  The currently values are
version_number = 1, and n_padding =1.

The scan name is repeated for every source, even if there are multiple 
sources in a scan.

Below is the delay file format in pseudo code. Between the square
brackets is the data type and the number of elements.

<header size>    [int32_t] # header size excluding this variable
<version_number> [int32_t] # version number
<n_padding>      [int32_t] # number of extra rows before and after each scan
<station name>   [(header_size - 8) * char]
* For each scan in the experiment
    * For each source in the scan
      <scan name> [char * 81]       # Null terminated scan name
      <source name> [char * 81]     # Null terminated source name
      <mjd> [int32_t]               # The modified julian day at the
                                      start of the scan
      * The model values sampled once per second
      time  U  V   W   delay   phase   amplitude [double]
      0 0 0 0 0 0 0 [double]   # The end of a scan (for each source)
                                 is marked with a row of zeros

Here time is the number of seconds since midnight on the day the scan
starts. U, V, W are in meters, and delay is in seconds.
</PRE>
           

<P>
 
<A NAME="logs"> 
<H2> Parsing log files </H2>

  This is the most frustrating part of data analysis. If you have 
data from VLBA, you do not need to run parsing log files. Parsing
log files from the KVN and VERA is very straightforward. Unfortunately,
parsing log files generated by the Field System developed in the Goddard
Space Flight Center often fails, because the format of field system
log file is changed without notice, and the developer who maintains
the field system refuses to cooperate.  
<P>
  
  <EM class="pima">PIMA</EM> can directly import log file in VLBA format 
or in the <EM CLASS="PIMA">PIMA</EM> ANTAB format. Non-VLBA logs are parsed 
by program log_antab and transformed to <EM class="pima">PIMA</EM> ANTAB 
format. Program log_antab extracts system temperature, if present, nominal 
on-off time tags, cable calibration and meteorological information. Modern 
VLBI analysis does not use in-situ meteorological information, and uses 
instead of that the output of numerical weather model. The current version 
of <EM class="pima">PIMA</EM> does not use nominal on-off time tags from log
files, since this information is already used by the correlator. 
<EM class="pima">PIMA</EM> can compute on-off from data actual time tags 
when the antenna was on source. The use of cable calibration in analysis is 
discretion and rarely improves the fit, and sometimes significantly degrade 
it. But the use of system temperature is critical for imaging. When 
<EM class="pima">PIMA</EM> produces the calibrated averaged visibilities,
it discards observations without system temperature.
<P>

  Syntax of the program for parsing log-files:
<PRE>
     Usage: log_to_antab {mode} {log_file} {antab_file} [year]
</PRE>
  where 
<UL>
    <LI> MODE =  1 &mdash; for IVS log-files after 2008. </LI><P>
    <LI> MODE =  2 &mdash; for IVS log-files in approximately 1999&ndash;2002. </LI><P>
    <LI> MODE =  3 &mdash; for IVS log-files in approximately 1996&ndash;1996. </LI><P>
    <LI> MODE =  4 &mdash; for IVS log-files in approximately 1996&ndash;1999. </LI><P>
    <LI> MODE =  5 &mdash; DBBC log file with USB/LSB pairs of BBCs. </LI><P>
    <LI> MODE = 11 &mdash; for KVN log-files</LI><P>
</UL>

  The main difficulty is in extraction system temperature from field system logs.
The parsing software needs to identify Tsys record, extract the array of Tsys and
match that array with sky frequencies. It needs to determine intermediate frequency
with respect to the frequency of the local oscillator, to determine the frequency
of the local oscillator, match them, find tsys record, determine to which BBC
a field in tsys record belong and match the field.
<P>

<B>NB:</B> An analyst should always examine the output of log_antab program.
Typical failure: log_to_antab fails to determine sky frequencies. Possible
reasons:  a log file may have a portion at the beginning or at the end that 
is related to another experiment, a new change of log format. In the first case,
editing a log file solves the problem. In the latter case you need to
patch log_to_antab. Please try not to break its ability to parse other log
files. If everything else fails, you can either develop your own parser or
to parse a log file by hand. Keep in mind that some station do not record
Tsys at all.
<P>

  Wrapper <EM class="wrap">pf.py</EM> supports log parsing. The following 
command does this: 
<PRE>
usage: <EM class="wrap">pf.py</EM> <EM class="val">EEE B</EM> <EM class="task">logs</EM>
</PRE>
    where <TT>EEE</TT> is the experiment name and <TT>B</TT> is the band. 
It creates output file <TT>EEE_AA.ant</TT>, where <TT>AA</TT> is a two 
character long low case antenna name. 

<A NAME="gean"> 
<H2> Calibrating the data </H2>

  FITS-IDI visibility file is supposed to have all calibration information 
inside. However, only Socorro correlator inserts all calibration information
into FITS-IDI. Visibility files from all other correlator missing some or
all calibration information.
<P>

  Although the visibility data from the old hardware VLBA correlator has all
calibration information, it is recommended to re-load it since in some cases
the calibration information is not correct and re-loading fixes the problem.
There is no need to reload calibration information to FITS-IDI files generated
in Socorro by DiFX 2.0 and newer.
<P>

  Field System log files contain a) on-off start/stop scan time; '
b) meteorological information; c) cable calibration; d) frequency table;
e) system temperature.  VLBA log files contain phase calibration phases
and amplitudes in addition to that.
<P>

  <EM class="pima">PIMA</EM> task <TT>gean</TT> inserted the calibration tables
into <EM CLASS="PIMA">PIMA</EM> internal data structures. Task 
<EM class="task">gean</EM> requires a qualifier that is followed by the value.
The following qualifiers are supported:

<UL>
    <LI><TT>pima_antab_file</TT> &mdash; loading Tsys, cable calibration,
            and meteorological information in <EM class="pima">PIMA</EM> ANTAB
            format. The value of this qualifier is the file name. One file 
            contains calibration information for one station.
            </LI><P>

    <LI><TT>vlba_log_file</TT> &mdash; loading Tsys, cable calibration,
            phase calibration and meteorological information in VLBA 
            calibration format. The value of this qualifier is the file 
            name. One file contains calibration information for all 
            stations that have VLBA data acquisition terminal, i.e ten 
            VLBA stations and EFLSBERG. The NRAO pipeline names this 
            file as <TT>EEEcal.vlba</TT>, where <TT>EEE</TT> is the name of 
            the experiment. 
            <P>

            Comment 1: After adopting DBBC in 2013, the NRAO has changed 
            the data processing chain. It still provides legacy calibration 
            file, but that legacy calibration is inadequate for processing
            DBBC data. <B> You should not load legacy calibration into 
            <EM class="pima">PIMA</EM> when processing DBBC NRAO data.</B>
            <P>

            Comment 2: Although FITS-IDI from analogue NRAO observations
            prior 2013 contains phase-calibration, system temperature,
            phase calibration, and phase calibration, it is desirable to
            re-load calibration into <EM class="pima">PIMA</EM> using task 
            <EM class="task">gean</EM>. The instances when calibration 
            information into FITS-IDI supplied by the NRAO was incorrect were 
            found.
            <P>
            
            Comment 3: <EM class="pima">PIMA</EM> issues warnings about missing
            phase-cal and Tsys. If <EM class="pima">PIMA</EM> uses phase 
            calibration and for a given observation phase calibration is missed,
            <EM class="pima">PIMA</EM> will declare that observation as "bad" 
            and will not perform fringe fitting. Though 
            <EM class="pima">PIMA</EM> will process such an observation if 
            <EM class="com">PCAL</EM>: <EM class="val">NO</EM> is specified in 
            the control file. As of 2016.01.17 <EM class="pima">PIMA</EM> task 
            <EM class="task">splt</EM> will bypass observations with missing 
            system temperature.

            </LI><P>

    <LI><TT>vlba_gain</TT> &mdash; inserts antenna gain information stored
            in VLBA gain file into <EM class="pima">PIMA</EM> data structures. 
            The value of the qualifier is the file name. The antenna gain file 
            is supposed to the VLBA gain format. This file can be found at 
            <A HREF="http://www.vlba.nrao.edu/astro/VOBS/astronomy/vlba_gains.key"> 
            http://www.vlba.nrao.edu/astro/VOBS/astronomy/vlba_gains.key</A>.
            It is updated several time a year. <EM class="pima">PIMA</EM> will 
            update gains only for stations that are defined in this file and 
            do not change gain of other stations.
            <P>

            Comment: Although FITS-IDI generated by NRAO at Socorro 
            contains antenna gains, it is desirable to re-load calibration 
            into <EM class="pima">PIMA</EM> using task 
            <EM class="task">gean</EM>. The instances when old calibration 
            information into FITS-IDI supplied by the NRAO was incorrect 
            were found.
            </LI><P>

    <LI><TT>evn_gain</TT> &mdash; inserts antenna gain information stored
            in the EVN antab format file into <EM class="pima">PIMA</EM> data 
            structures. The value of the qualifier is the file name. 
            <EM class="pima">PIMA</EM> will update gains only for stations 
            that are defined in this file and do not change gain of other 
            stations.
            </LI><P>

    <LI><TT>pcal_off</TT> &mdash; turns the phase calibration off for 
            a given station. The value of this qualifier is the station
            name. <EM class="pima">PIMA</EM> turns off the flag of phase 
            calibration availability. As a results <EM class="pima">PIMA</EM> 
            considers that phase-calibration is unavailable for that station. 
            The flag can be turned on back. If pcal was turned off for a given
            station, it cannot be turned by a fine-grained 
            <EM class="com">PCAL</EM> option.
            </LI><P>

    <LI><TT>pcal_on</TT> &mdash; turns the phase calibration on for 
            a given station. The value of this qualifier is the station
            name. This operation undoes operation pcal_off and sets 
            flag of phase calibration availability. Of course, this 
            operation will have effect only if there are phase calibration
            data loaded in <EM class="pima">PIMA</EM> internal data structure.
            If pcal was turned on for a given station, it can be turned off by 
            a fine-grained <EM class="com">PCAL</EM> option.
            </LI><P>

    <LI><TT>tsys_off</TT> &mdash; turns off Tsys for a given station. The value of 
            this qualifier is the station name. This task turns Tsys availability. 
            As a results <EM class="pima">PIMA</EM> skips that station for imaging. 
            The flag can be turned on back. Turning Tsys off may be necessary
            if Tsys is missing or corrupted, or a user wants to avoid using 
            that station for imaging for any reason.
            </LI><P>

    <LI><TT>tsys_on</TT> &mdash; turns Tsys on for a given station. The value of 
            this qualifier is the station name. This task undoes <TT>tsys_off</TT>
            and makes Tsys availability if Tsys data are loaded in 
            <EM class="pima">PIMA</EM>.
            </LI><P>

    <LI><TT>wvr</TT> &mdash; processes water vapor radiometer data into 
            <EM class="pima">PIMA</EM> internal data structures. This qualifier
            has value either <EM class="val">load</EM>, 
            <EM class="val">plot1</EM>, and <EM class="val">plot2</EM>. All 
            these operations load all WVR data specified in the keyword(s) 
            <EM CLASS="com">WVR_FILE</EM> in the control file. If the value of 
            <TT>wvr</TT> qualifier is <EM class="val">plot1</EM>, then in 
            addition to loading, <EM class="pima">PIMA</EM> will generate a 
            plot of WVR path delay versus time. If the value of <TT>wvr</TT> 
            qualifier is <EM class="val">plot1</EM>, then in addition to loading, 
            <EM class="pima">PIMA</EM> will generate a plot of WVR path delay 
            versus elevation.
            </LI><P>
</UL>
<BR>

NB: Antenna gain, system temperature, meteorological information and cable
calibration does not change result of fringe fitting. Therefore, these 
calibration can be applied after fringe fitting. Phase calibration affects
result of fringe fitting. Therefore, it is supposed to perform this kind
of calibration before fringe fitting. If you changed phase calibration, 
phase calibration status (pcal_on, pcal_off), you have to redo bandpass
calibration and fringe fitting. Otherwise, you will get <B>wrong results</B>.

<A NAME="gean"> 
<H2> Examine raw data and calibration information </H2>

  An analyst must always examine the data and calibration information
before running fringe fitting as carefully as possible. If an error will
not be noticed at the initial examination, then the analysis will be 
have be redone. Attentiveness during early examination saves time and
reduces the probability that the error will not be noticed and will lead
to an erroneous result.
<P>

<UL>
     <LI> Examining gean log files. This file has information about
          possible errors in FITS-IDI. Keyword 
          <EM class="com">CHECK_SEVERITY:</EM> 2 in the control file will 
          cause <EM class="pima">PIMA</EM> stop at many errors. Keyword 
          <EM class="com">CHECK_SEVERITY:</EM> 1 will allow to continue 
          loading with a damaged visibility file. However, 
          <EM class="pima">PIMA</EM> recovery algorithm may be too 
          permissive. Sometimes, data may require flagging after loading 
          corrupted FITS-IDI.
          </LI><P>

    <LI> When <EM class="pima">PIMA</EM> successfully loads the data, it 
         creates a number of dumps files. They are created to facilitate 
         inspection of the data.
         <P>

    <UL>
         <LI> Examining statistics file. Upon successful loading, 
              <EM class="pima">PIMA</EM> creates statistics file and 
              <TT>SSSSS/EEE.stt</TT>, where is <TT>SSSSS</TT> the 
              <EM class="pima">PIMA</EM> scratch directory specified in 
              <EM class="com">EXPER_DIR</EM> keyword of the control file, 
              and <TT>EEE</TT> is the lower case experiment name. An analyst 
              should check among other things a) whether all FITS-IDI were 
              read; b) whether the data have all polarizations, c) whether 
              the data for all time range were read (nominal start and stop 
              date); d) whether data from all stations were read.
              </LI><P>

         <LI> Examining the source list. Upon successful loading, 
              <EM class="pima">PIMA</EM> writes the source file dump in 
              <TT>SSSSS/EEE.sou</TT>. This file is just the ascii dump of 
              the internal source table. You should examine source names and 
              a priori source coordinates. <EM class="pima">PIMA</EM> gets 
              a priori source coordinates from the catalogue file. In general, 
              the a priori source coordinates are not the same as the 
              coordinates used by the correlator. However, if the differences 
              are large (say, more than 10 mas), an analyst should be aware of 
              that. Large discrepancies between the a priori coordinates
              used by the correlator and those specified in the catalogue 
              may trigger a parabolic phase correction. This corrections 
              needed if the coordinates used by the correlator were not 
              precise. But this correction will degrade the results and
              even cause a non-detection if the a priori coordinates in
              the catalogue are wrong, f.e. a wrong source name was 
              associated.
              </LI><P>

         <LI> Examining the frequency list. <EM class="pima">PIMA</EM> writes 
              the frequency file dump in <TT>SSSSS/EEE.frq</TT>. 
              <EM class="pima">PIMA</EM> sorts the frequencies and transforms 
              low side band data with frequencies running in the decreasing 
              order into upper side band data with frequencies running in the 
              increasing order. <EM class="pima">PIMA</EM> control file 
              supported keywords <EM class="com">BEG_FRQ</EM>, 
              <EM class="com">END_FRQ</EM>, and <EM class="com">FRQ_GRP</EM> 
              that have intermediate frequency or frequency group indices as 
              their values. An analyst should be aware to which sky frequencies 
              these indices correspond.
              </LI><P>
            
         <LI> Examining the station list. <EM class="pima">PIMA</EM> writes 
              the frequency file dump in <TT>SSSSS/EEE.sta</TT>. The file has 
              information about station names, station coordinates, and number
              of Stokes parameters.
              </LI><P>

         <LI> There are other dump files, but normally they should
              be inspected in a case of problems. File with extension
              <TT>.obs</TT> lists the observations, observing stations, 
              observed
              sources, start and stop time. File with extension .sca
              lists the scans, observed sources, stop and start dates.
              File with extension <TT>.tim</TT>lists time tags of valid 
              visibilities. File with extension .mod lists start and
              stop time for parameters of the interferometric model.
              File with extension .mdu shows association of observations
              with intervals of interferometric model. File with 
              extension .mdc lists parameters of clocks used in the 
              correlator model. File with extension .mda lists 
              parameters of the atmosphere path delay used by the 
              correlator. Very long file with extension .uv lists 
              all cross-correlation and autocorrelation visibilities.
              File with extension .dup shows duplicate visibilities.
              File with suffix _uv.exc lists indices of excluded
              visibilities if <EM class="com">UV_EXCLUDE_FILE:</EM> 
              <EM class="val">AUTO</EM> was specified in the 
              <EM class="pima">PIMA</EM> control file.
              </LI><P>
    </UL></LI><P>

    <LI> Examining phase calibration. <EM class="pima">PIMA</EM> has 
         a special task <EM class="task">pcpl</EM>. 
         It is useful for examining 1 to 8 phase calibration tones
         per IF. If there are more phase cal tones, the plot become
         crowded what makes it difficult to read. An analyst should
         make a decision whether phase calibration signal is useful
         or not. Keep in mind, DiFX correlator will extract signal
         at frequencies where it supposed to be regardless whether
         phase calibration unit was on or off. If the unit was off,
         phase calibration phases will be a noise, and applying such
         phases will ruin observations completely. 
         <EM class="pima">PIMA</EM> task <EM class="task">gepm</EM> 
         will catch this case and mask out such tones.
         <P>

         What to look? First to look at phase cal phases. Phase cal
         scatter with respect to a smoothed curved should not be 
         excessive (more than 0.3 rad). Sometimes phase calibration
         may vary significant with time. Plot of "phase cal relative f0"
         (R), i.e. differences of phase calibration phases with respect
         to the phase at the lowest frequency is helpful in this 
         situation. Another useful statistics is "phase cal amplitude"
         (M). There are several factors that causes variation of phase-cal
         amplitudes. Phase calibration amplitude is proportional to 
         T_sys, which depends on elevation and may depend on time.
         The second factor is presence of spurious narrow-band signal(s)
         generated by the hardware. This signal distorts phase and 
         amplitude of the phase-calibration signal. If front-filters 
         are not tuned well, the phase calibration signal at the image
         sub-band may distort phase and amplitude of the phase cal signal
         at the primary sub-band. Plot of "phase amp versus phase" (V)
         help to reveal the presence of spurious signals. There is
         no dependence of phase calibration amplitude on phase if
         the hardware is perfect. Sinusoidal pattern indicates the 
         presence of spurious signals. Spurious signal with amplitude
         less than 10% of the average amplitude are usually harmless,
         while the use of phase calibration with spurious signals with 
         the amplitude 50% may significantly degrade results. 
         <EM class="pima">PIMA</EM> task <EM class="task">gepm</EM> 
         implements all of these heuristics in a repeatable and automatic 
         way. After running <EM class="task">gepm</EM>, it is a good idea 
         to look at phase calibration once more to determine whether any 
         spurious signals remain.
         <P>
     
         An analyst should make a decision whether to keep phase 
         calibration for a given station or not. <EM class="pima">PIMA</EM> 
         allows to disable phase calibration for any given station or for 
         all stations. In order to disable phase calibration for all the 
         stations, <EM class="com">PCAL</EM>: <EM class="val">NO</EM> should 
         be specified in the control file. Task <EM class="task">gean</EM> 
         allows to disable phase calibration for a given station. 
         It requires qualifier pcal_off that needs a value: station 
         name. If to run task <EM class="task">gean</EM> with qualifier 
         <EM class="val">pcal_on</EM>, the phase calibration for a given 
         station will be enabled. <B>NB:</B> if you loaded the experiment with 
         <EM class="com">PCAL:</EM> <EM class="val">NO</EM>, 
         <EM class="pima">PIMA</EM> does not read phase calibration, and 
         therefore task <EM class="task">gean</EM> cannot be enabled it. 
         You need to load the experiment again in order to enable phase 
         calibration.         
         <P>
         Task <EM class="task">pcpl</EM> supports an optional qualifier
         <EM class="val">pcal_type</EM> that can take value 
         <EM class="val">raw</EM> and <EM class="val">average</EM>.
         By default, <EM class="pima">PIMA</EM>  averages phase calibration
         within a scan, and task <EM class="task">pcpl</EM> shows averaged
         phase calibration phases and amplitudes. If <EM class="val">raw</EM>
         is selected, no averaging is performed.

         <P>

         In addition, <EM class="pima">PIMA</EM> provides a fine-grained
         mechanism for toggling status to use or not to use pcal for 
         given stations. Keyword <EM class="com">PCAL</EM> supports 
         a qualifier that provides a station list.
         <P>

         Syntax:
         <P>

         <EM class="com">PCAL</EM>:  <EM class="val">value[:action:[station[:station]...]</EM>
         <P>

         A separator : (column) or , (comma) between stations is allowed.
         <P>

         Action is either TO_USE or NOT_TO_USE. The action is 
         case insensitive. If action is TO_USE, then pcal only from
         the stations form the list will be used. If action is NOT_TO_USE,
         then pcal from the stations on the list will not be used.
         Example:
         <P>

<PRE>
         PCAL:   USE_ALL:NOT_TO_USE:MEDICINA:NYALE13S:RAEGSMAR:YARRA12M
</PRE>

         Here phase calibration from the following stations, MEDICINA, 
         NYALE13S, RAEGSMAR, YARRA12M will not be used.
         <P>

<PRE>
         PCAL:   USE_ALL:to_use:HART15M,KOKEE,WETTZELL
</PRE>

         Here phase calibration only from the following stations, 
         HART15M,KOKEE,WETTZELL will be used provided the phase 
         is available and was not turned off with task gean.
         <P>

         Fine-grained pcal station selection can change phase calibration
         use status <B>only if pcal is available and was not turned off
         using task <EM class="task">gean</EM></B>.
         </LI><P>

    <LI> Examining system temperature. <EM class="pima">PIMA</EM> task 
         <EM class="task">tspl</EM> displays system temperature for a given 
         IF. By default, <EM class="task">tspl</EM> shows Tsys for the first 
         IF. The IF index can be changed by hitting box "Frequency selection" 
         (V). Tsys can be displayed versus time (T) and versus elevation (E).
         Tsys can be decomposed in the product of Tsys in the zenith direction
         as a function of time and the Tsys elevation dependence. The first
         part, Tsys in the zenith direction is show by button (Z). The 
         second, Tsys as a function of elevation angle is shown by button (D).
         <P>
      
         What to look? If <EM class="pima">PIMA</EM> shows no Tsys, that means 
         it was not loaded. If need to check log file and if possible, to fix. 
         Then you need to re-run task <EM class="task">gean</EM>. Sometimes Tsys 
         is so noisy or wrong that keeping such a station will degrade 
         reconstructed source images. In that case bad Tsys in certain IFs can 
         be disabled by editing so-called gain correction file specified by the 
         <EM class="com">GAIN_CORRECTION_FILE</EM> control file. 
         <EM class="pima">PIMA</EM> task <EM class="task">load</EM> creates and 
         initializes it if the file specified by that control file does 
         not exist. The gain corrections file specifies for each station,
         each IF a factor that <EM class="task">splt</EM> will multiplies Tsys. 
         <EM class="pima">PIMA</EM> does not modify the file if it exist. 
         An alternative way to initialize gain correction file is to run task 
         <EM class="task">gaco</EM> with qualifier <EM class="val">init</EM>. 
         That qualifier requires a value either fill or overwrite. Value 
         <EM class="val">fill</EM> instructs <EM class="pima">PIMA</EM> to add 
         missing records: if for some 
         IFs, some stations the gain correction was not defined, 
         <EM class="pima">PIMA</EM> will add record with correction equal to 1
         (i.e. no correction). If the qualifier init has value overwrite, 
         <EM class="pima">PIMA</EM> will overwrite previous definitions with 1.
         If for a given IF, given station the gain correction is 0.0, then
         <EM class="pima">PIMA</EM> task <EM class="task">splt</EM> will set 
         amplitude zero and such an IF will not be used for imaging.
         </LI><P>

    <LI> Running a trial fringe fit for a given observation. It has sense to 
         look at fringe plot of several scans of a strong source. A number of
         strong sources are usually observed in a well designed experiment.
         Examining dump with extension <TT>SSSSS/EEE.obs</TT> helps to find 
         indices of observations of strong sources. Wrapper 
         <EM class="wrap">pt.py</EM> is useful for running a trial fringe fit. 
         It has the following syntax:
        <P>
        Usage: <EM class="wrap">pt.py</EM> <EM class="com">[-pt optios]</EM> <EM class="val">EEE B obs</EM> <EM class="com">[pima_opts]</EM>
        <P>

        where is the low case experiment name, band is the low case
        band name, and obs is the observation index. These mandatory 
        arguments may be followed by additional arguments of the command line 
        for <EM class="pima">PIMA</EM> that are in the usual format keyword: 
        value. The wrapper itself supports options --dry-run (-r) and 
        --verbosity (-v). Option --dry-run just shows the 
        <EM class="pima">PIMA</EM> command line without execution. Option 
        --verbosity requires a value. Value <EM class="val">0</EM> means no 
        informational messages, value <EM class="val">1</EM> (default) moderate 
        verbosity and values <EM class="val">2</EM> and <EM class="val">3</EM> 
        more and more verbose output.
        <P>

        If the <EM class="pima">PIMA</EM> control file defines 
        <EM class="com">BANDPASS_FILE</EM>, and/or 
        <EM class="com">BANDPASS_MASK_FILE</EM>, and/or 
        <EM class="com">PCAL_MASK_FILE</EM>, and/or 
        <EM class="com">POLARCAL_FILE</EM> that do not exist, wrapper 
        <EM class="wrap">pt.py</EM> replaces them with 
        <EM class="val">NO</EM> and issues a warning.
        <P>

        <EM class="wrap">pt.py</EM> displays two fringe plots: versus frequency 
        (and averaged over
        time) and versus time (and averaged over frequency). If a source is
        weak, the plot may look too noisy. Keyword 
        <EM class="com">FRIB.1D_FRQ_MSEG</EM> averages
        the data over frequency after performing fringe fit and before
        plot preparation. The value of the keyword specifies how many spectral
        channels are coherently averaged out. This parameter should not exceed
        the total number of spectral channels in an IF. Analogously,
        <EM class="com">FRIB.1D_TIM_MSEG</EM> averages the data over time after 
        performing fringe fit and before plot preparation. The value of the 
        keyword specifies how many accumulation periods are coherently 
        averaged out. 
        <P>         
        
        What to look? First, whether the source is detected. As a rule of 
        thumb, SNR &gt; 7.0 and higher indicates a reliable detection,
        SNR in a range of [6.0, 7.0] is a marginal detection, SNR in a range
        [5.1, 6.0] is unlikely a detection, and SNR &lt; 5.1 usually is 
        a non-detection. If an observation you picked is a non-detection,
        try another. If <I>all</I> observations are non-detections &mdash; 
        bad luck, you can stop analysis on this point. Nothing can be done.
        <P>         

        Since no bandpass calibration is applied at this point, the phases
        are not aligned. However, the residual fringe phases should follow
        a more or less a smooth line for a high SNR observation. Jumps, or
        low amplitudes at some IFs raises a concern. Phase behavior at
        individual IFs can be examined by running <EM class="wrap">pt.py</EM> 
        with specifying the IF under consideration with keywords 
        <EM class="com">BEG_FRQ</EM> and <EM class="com">END_FRQ</EM>.
         </LI><P>
   </UL>
</UL>


<A NAME="coarse"> 
<H2> Running coarse fringe fitting </H2>

  The goal for coarse fringe fitting is preparation for bandpass 
computation and for initial data examination. Coarse fringe fitting
uses single polarization data (RR for dual-polarization data), does
not use bandpass, because usually bandpass is not known at that time,
and uses no oversampling in order to speed up computation, and performs
the parabolic fine fringe search. Therefore, the following parameters 
are always set:

<PRE>
BANDPASS_USE:          NO
BANDPASS_FILE:         NO
POLARCAL_FILE:         NO
FRIB.OVERSAMPLE_MD:    1
FRIB.OVERSAMPLE_RT:    1
FRIB.FINE_SEARCH:      PAR
MKDB.FRINGE_ALGORITHM: DRF
</PRE>

If the bandpass mask file is not available, then 
<EM class="com">BANDPASS_MASK_FILE:</EM> NO
is set. <EM class="com">POLAR:</EM> RR is set for dual-polarization or 
RR data and <EM class="com">POLAR:</EM> LL is set to LL-polarization data. 
Usually <EM class="pima">PIMA</EM> runs in both coarse and fine fringe fitting mode. 
It is desirable to store results  of coarse and fine fringe fitting in 
separate files. Therefore, when we run coarse fringe fitting, we set 
<EM class="com">FRINGE_FILE</EM> and <EM class="com">FRIRES_FILE</EM>
into different files than those specified in the <EM class="pima">PIMA</EM> control file.
<P>

  To run coarse fringe fitting, task  <EM class="task">frib</EM> is used. 
<EM class="pima">PIMA</EM> wrapper <EM class="wrap">pf.py</EM> simplifies 
running coarse fringe fitting. Syntax:

<PRE>
 Usage: <EM class="wrap">pf.py</EM> <EM <EM class="val">EEE B coarse</EM> 
</PRE>

  where <TT>EEE</TT> is the experiment name and <T>B</TT> is band in lower 
case. Wrapper will write fringe result in <TT>VVVVV/EEE/EEE_B_nobps.fri</TT> 
and fringe  fitting residuals into <TT>VVVVV/EEE/EEE_B_nobps.frr</TT> files.

<A NAME="bpas"> 
<H2> Computation of a complex bandpass </H2>

   Computation of the complex bandpass is the second major task that
requires human intervention. The bandpass of the ideal system is rectangular
shape for the amplitude and zero for phase. That means that cross-correlation
spectrum of a signal from a radio sources with continuum flat spectrum is
also flat with some constant phase offset and the multiplicative factor
that is proportional to the square root of the products of Tsys at both
stations. Unfortunately, up to date perfect VLBI hardware is not yet 
developed. The cross-correlation spectrum diverts from the ideal (flat phases
and flat amplitudes). The use of phase-calibration may alleviate the deviation
from the ideal spectrum, may have no visible effect or may even degrade it, but
never fixes phases. Therefore, normally a complex function of frequency is 
computed that being multiplied by the cross-spectrum makes it flat. This function
can be computed reliably using sources with SNR &gt; 200, but preferably
with SNR > 1000. A good principle investigator does not hesitate to spend a sizable
amount of allotted time for observing bright sources that are used as calibrators.
Bandpass calibration can still be performed using source with SNR 40&ndash;200,
but less reliable. Quality of bandpass derived using observations with SNR
in  a range 10&ndash;40 is questionable. Bandpass calibrator sources are supposed
to be continuum with the spectrum flat within an IF. Any active galaxy nuclea
satisfies this condition.
<P>
 
  In a case when phase calibration is applied, the bandpass is computed with
respect to the phase calibration. If you use all tones of phase calibration,
you should first clean them and mask out the tones affected by internal 
radio interference (spurious signals).
<P> 

   It is assumed the residual bandpass is stable with time. An experiment may 
have jumps in the bandpass due to power-off power-on
of the VLBI hardware at one or more stations. Unfortunately, as of 2016.02.01 
<EM class="pima">PIMA</EM> does not provide a convenient way for processing 
such data. The workaround is to effectively split the dataset into two subsets 
before and after the jump and compute two bandpasses. Splitting  the dataset 
can use made using keywords <EM CLASS="com">OBS</EM>, 
<EM CLASS="com">INCLUDE_OBS_FILE</EM>, and 
<EM CLASS="com">EXCLUDE_OBS_FILE</EM>. Fortunately, jumps in bandpass 
occur in less than 5% VLBI experiments.

<P>
   An analyst usually sets the mask for cross-spectrum data during this step.
The mask is an array of 1 and 0 that depends on spectral channel index. 
<EM class="pima">PIMA</EM>
multiplies the mask by visibilities when it processes the data. Zeroes in the
mask effectively replaces the spectral channels with zeroes. Usually unwanted
potion of the spectrum is masked out: either affected by RFI or affected by 
hardware bandpasses. If a signal is narrow-band, for instance from an stellar
maser, then masking allows to discard spectral channels that have no signal,
but only noise.

<H3> Cleaning phase calibration </H3>

If you use four or more tones of phase calibration per IF, you should first 
clean them and mask out the tones affected by internal radio interference. 
Old VLBA hardware extracted two phase calibration tones per IF. <EM class="pima">PIMA</EM> treats
this case as a single tone per IF. A user can select which tone to use.
If less four tones per IF was extracted in your experiment or you do not
apply multiples phase cal tones per IF, just skip this section.
<P>

  Usually, phase calibration signal is a rail of very narrow-band signals 
with frequency separation 1 MHz which less than the spectral resolution
of visibility data. <EM class="pima">PIMA</EM> interpolates spectrum of 
phase calibration within each IF. In a case if only one tone per IF 
is used <EM class="pima">PIMA</EM> considers phase spectrum of the 
calibration signal is flat, i.e. it assigns the phase  calibration phase 
to all spectral channels. In a case if all phase calibration tones are 
used, <EM class="pima">PIMA</EM> unwraps phases and performs linear 
interpolation or extrapolation. The presence off spurious signals 
distorts calibration phases. If they affect a small fraction of all 
tones, the tones affected by spurious signals can be masked out. 
Then <EM class="pima">PIMA</EM> will automatically interpolated between
tones that are not affected.
<P>

  Task <EM class="com">mppl</EM> shows phase and amplitudes of phase 
calibration signal with multiple tones per IF. It may be useful to use 
keyword <EM CLASS="com">OBS</EM> to control which observations to use 
for generating plots. 
<P>

  Task <EM class="com">mppl</EM> shows several types of plots. Raw phase 
usually is not informative, since the calibration signal may have many phase 
turns per IF. Let <EM class="pima">PIMA</EM> to unwrap phase for you. 
Plot of unwrapped phases (U) shows the spectrum: unwrapped phases (green) 
and modeled phases (blue). Bandpass is supposed to be smooth. Jumps in 
phases is due to spurious signals. The sum of the phase calibration tone 
and the spurious signal depends on the phase of  the phase calibration tone 
itself. Therefore, if at a given plot of a given observation you see phase 
that does not strongly deviate from the smoothed curve that does not 
necessarily means that other observation will not be affected even if the 
source of spurious signals does not depend on time. Mode (C) displays both 
unwrapped phase and amplitude at the same plot. Since spurious signal affect
both phase and amplitude of the calibration signal, this plot helps to 
identify frequencies affected by spurious signals.
<P>

  OK, you found a peak at the plot that you believe is due to the spurious 
signal. What further? <EM class="pima">PIMA</EM> supports so-called phase 
calibration mask file specified by the keyword 
<EM CLASS="com">PCAL_MASK_FILE</EM>. This file defines the value, 0 or 1, 
for <B>each</B> phase calibration tone. If the value is zero, then that 
calibration tone is masked out and not used for computation of the 
smoothed curve that interpolates the phase calibration signal across 
an IF. One may edit this file manually, but in general, it is too boring. 
<EM class="pima">PIMA</EM> supports so-called mask definition files that 
allows to write which calibration tones to suppress in a concise way. 
It allows to define ranges of the tones that are to be mask out. 
An analyst edits the calibration mask definition file, converts it to 
the phase calibration mask, visualizes the phase calibration phases 
and/or amplitudes and repeat this procedure till a satisfactory result 
is produced.
<P>

  Phase calibration mask definition file consists of records of variable
length. The first record identifies the format. It should always be
be <TT># <EM class="pima">PIMA</EM> PCAL_MASK_GEN  v  1.00 2015.05.10</TT>
Lines that start with '#', except the first one, are considered comments,
and the parser ignores them. Mask definition records consists of 8 words
separated by one or more blanks
<TT>
PCAL  STA: ssssssss  IND_FRQ: aa-bb  IND_TONE: xx-yy  OFF
</TT>
<P>

  where <TT>sssssss</TT> is the station name, <TT>aa</TT> is the index of 
the first IF of the range, <TT>bb</TT> is the index of the last IF of the range,
<TT>xx</TT> is the index of the first tone in a given IF range and 
<TT>yy</TT> is the index of the last tone in a given IF range. 
Here is an example:

<PRE>
# <EM class="pima">PIMA</EM> PCAL_MASK_GEN  v  1.00 2015.05.10
#
#  Phase calibration mask definition file for VLBI experiment VEPS02
#
#  Last updated on  2015.05.13_12:35:17
#
PCAL  STA:   KUNMING     IND_FRQ:   1-1   IND_TONE:   30-31  OFF
PCAL  STA:   SESHAN25    IND_FRQ:   8-8   IND_TONE:    4-4   OFF
PCAL  STA:   URUMQI      IND_FRQ:   1-16  IND_TONE:    1-1   OFF
</PRE>

  The first line identifies the format. The file defines the mask that
deselects tones with indices 30&ndash;31 of the first IF for station KUNMING,
the tone with index 4 for the 8th IF for station SESHAN25, and the first tone
in all IFs from the 1st to the 16th for station URUMQI. 
<P>

  <EM class="pima">PIMA</EM> does not accept the mask definition file directly. 
Task <EM class="com">pmge</EM> transforms the phase calibration mask definition 
file into phase calibration mask file. That task requires qualifier 
<EM class="val">mask_gen</EM> with value mask definition file. The name of 
the output file is defined by keyword <EM CLASS="com">PCAL_MASK_FILE</EM> in 
the <EM class="pima">PIMA</EM> control file. Example:

<PRE>
pima ru0186_x_pima.cnt pmge mask_gen ru0186_pcal_mask.gen
</PRE>

Comments:
<UL>
    <LI> Masking a phase calibration tone also excludes 
         from unwrapping the phase calibration phase. The phase unwrapping algorithm
         subtracts group delay in the calibration signal. Therefore, removal of one or
         more points, especially of they were outliers, changes the unwrapped phases.
         </LI><P>

    <LI> Usually a mask is applied to all observations. Some spurious signals 
         may go on and off. Therefore it is a good idea to look at phase calibration
         at different parts of the experiment.
         </LI><P>
</UL>
<P>

  Automatic masking is done through the <EM class="pima">PIMA</EM> 
task <EM class="com">gepm</EM>. This task has three required parameters 
and three optional parameters. The first is <TT>sta</TT>, which selects 
the station for which automatic phase calibration masking is to be done. 
Passing the <TT>sta</TT> parameter the value <TT>all</TT> will automatically 
mask all phase calibration tones at once and is the normal mode of 
operation. The second required parameter is <TT>tim_mseg</TT>, which 
controls the averaging interval of phase calibration data. 
<EM class="com">gepm</EM> will average phase calibration data such that 
the interval between phase calibration samples is as close to this 
parameter as possible. If phase calibration data has a relatively high sample 
rate, increasing this parameter may improve the results of automatic phase 
calibration masking. Passing a value of tim_mseg below the sampling 
interval of the phase calibration data leaves the data unchanged, thus 
passing <TT>tim_mseg 0</TT>  will always result in no averaging of data. 
The third required parameter is <TT>overwrite</TT>, which should always 
be given as <TT>overwrite yes</TT>. This indicates that it is
acceptable to overwrite the existing phase calibration mask file.
<P>

  The three optional parameters pertain to the methods used in automatic 
phase calibration masking. The first is <EM class="val">tim_thresh</EM>, 
which controls the threshold fraction of flagged epochs at which a phase 
calibration tone is masked out. The default value is 0.1, or 10% 
flagged epochs for masking out. An epoch is flagged when the modeled 
phase of the phase calibration tone differs from the measured phase by more than 
<EM class="val">diff_thresh</EM>, indicating a discontinuity typical of a spurious 
signal. <EM class="val">diff_thresh</EM>, the second  optional parameter, thus 
determines the level of discontinuity in the frequency domain in an 
IF indicative of a spurious signal. The default value of this parameter 
is 0.15 radians. This can be increased to reduce the number of masked out
tones or lowered to increase the number of masked out tones. Be careful 
of lowering it too much, as healthy tones may be flagged due to normal 
phase jitter. The third optional parameter is <EM class="val">max_count</EM>.
This controls the maximum allowed number of statistically significant 
jumps in the phase time series a tone may have. The default value is 50.  

<P>

Upon completion of <EM class="com">gepm</EM>, several files are 
produced. The first is an indication of the health of the phase 
calibration tones in the form of the root-mean-square phase jitter 
in the time domain and the frequency domain. This file is saved in 
the form <TT>exp_band_pcal_rms.txt</TT>. <EM class="com">gepm</EM> 
also produces a report file of the form <TT>exp_band_pcal_report.gen</TT>. 
This report file shows the specific tones that have been masked out
as well as the reason for their masking out. In addition, this report 
file can be hand-edited to turn off additional tones and turned into 
a phase calibration mask using the task <EM class="com">pmge</EM> with 
the usual syntax, calling the report file as the generator file.
An excerpt of a typical rms file and report file are shown below:

<PRE>
# <EM class="pima">PIMA</EM> PCAL_RMS   Format of 2022.06.30
# 
# PCAL_RMS file for experiment r41056
# 
# created by # PIMA PCAL_RMS_GEN  v  1.00 2022.06.30 on 2023.01.02-20:26:23
# using control file /vlbi/r41056/r41056_s_pima.cnt
# 
AVERAGE TIME SPACING:      8.606 SEC
TIME DIRECTION RMS PHASE CALIBRATION JITTER (RAD) BY CHANNEL:
BADARY   IND_FRQ:     1 IND_TONE:      1 IND_ABS_CHN:       9 RMS:      0.009
BADARY   IND_FRQ:     1 IND_TONE:      2 IND_ABS_CHN:      10 RMS:      0.009
FREQ DIRECTION RMS PHASE CALIBRATION JITTER (RAD) BY IF:
BADARY   IND_FRQ:     1           0.017
BADARY   IND_FRQ:     2           0.008
</PRE>

<PRE>
# <EM class="pima">PIMA</EM> PCAL_RPT   Format of 2022.07.07
# 
# PCAL_RPT file for experiment r41056
# 
# created by # PIMA PCAL_RPT_GEN  v  1.00 2022.07.07 on 2023.01.02-20:26:23
# using control file /vlbi/r41056/r41056_s_pima.cnt
# 
PCAL  STA:  BADARY   IND_FRQ:     3-3   IND_TONE:     8-8    OFF !    Problem:  SPURIOUS SIGNAL     
PCAL  STA:  BADARY   IND_FRQ:     6-6   IND_TONE:     3-3    OFF !    Problem:  SPURIOUS SIGNAL     
PCAL  STA:  BADARY   IND_FRQ:     6-6   IND_TONE:     5-5    OFF !    Problem:  SPURIOUS SIGNAL     
#  
PCAL  STA:  MEDICINA IND_FRQ:     3-3   IND_TONE:     1-1    OFF !    Problem:  PHASE JUMPS         
PCAL  STA:  MEDICINA IND_FRQ:     3-3   IND_TONE:     2-2    OFF !    Problem:  PHASE JUMPS         
PCAL  STA:  MEDICINA IND_FRQ:     3-3   IND_TONE:     3-3    OFF !    Problem:  PHASE JUMPS
</PRE>

In addition, if all phase calibration tones are noise for a given 
station, this will be reported to the user as a text output in the 
terminal. A clock break detection scheme is also implemented, and 
any detected clock breaks will be reported along with the time in 
the time series at which the break occurred. A typical execution 
and terminal output is shown below:

<PRE>
pima r11039_s_pima.cnt gepm sta all tim_mseg 10 overwrite yes tim_thresh 0.1 diff_thresh 0.15 max_count 50
 All pcal tones of station SEJONG   are noise. Recommend adding to  PCAL: not_to_use:  in control file
 All pcal tones of station SVETLOE  are noise. Recommend adding to  PCAL: not_to_use:  in control file
 All pcal tones of station YARRA12M are noise. Recommend adding to  PCAL: not_to_use:  in control file
 For station AGGO     short-term spurious signal near t =    68973.830720024562       sec
 For station HART15M  short-term spurious signal near t =    28750.155200028232       sec
 For station NYALES20 short-term spurious signal near t =    11917.828159952907       sec
 For station NYALES20 likely clock break near t =    57313.701440090219       sec
 For station ONSALA60 short-term spurious signal near t =    55581.286400066594       sec
 For station SESHAN25 likely clock break near t =    13436.420480009539       sec
 For station SESHAN25 likely clock break near t =    70135.392319724342       sec
WRI_PCAL_RMS: pcal rms file is written in /vlbi/r11039/r11039_s_pcal_rms.txt
WRI_PCAL_MASK: pcal mask is written in /vlbi/r11039/r11039_pcal.mask
WRI_PCAL_RPT: pcal rpt file is written in /vlbi/r11039/r11039_s_pcal_report.gen
</PRE>

<EM class="com">gepm</EM> has also been added to the wrapper 
<EM class="wrap">pf.py</EM> to make it easier to use in the fringe 
fitting process. To call <EM class="com">gepm</EM> from 
<EM class="wrap">pf.py</EM>, the user needs only to specify 
<EM class="val">overwrite</EM>. All other parameters have listed defaults. 
Thus, a minimal function call might look like,

<PRE>
 Usage: <EM class="wrap">pf.py</EM> <EM <EM class="val">exp band </EM> <EM class="com">gepm</EM> <EM class="com">-overwrite</EM> <EM class="com">[-sta,-tim_mseg,-tim_thresh,-diff_thresh,-max_count]</EM>
</PRE>

When using <EM class="wrap">pf.py</EM>, the output from the terminal 
including warnings about clock breaks is written to a log file. 
A condensed phase calibration generator file is also formed from 
the report file, which increases readability but does not list 
reasons for tone being masked out. It is saved according to the 
name of the phase calibration mask file by replacing <TT>.mask</TT> 
with <TT>_mask.gen</TT>. i.e. for <EM CLASS="com">PCAL_MASK_FILE:</EM> 
<TT>r41056_s_pcal.mask</TT>, the mask generator is saved to 
<TT>r41056_s_pcal_mask.gen</TT>.

<H3>Masking auto- and cross-correlation spectral channels</H3>

  <EM class="pima">PIMA</EM> allows to mask out specified channels of 
either auto or cross-spectrum or both. The auto-correlation spectrum 
is corrupted by the presence of internal RFI generated in the vicinity 
of the data acquisition system. Usually the internal RFI causes 
appearance of peaks in the auto-correlation spectrum. As a rule of thumb 
peaks with the amplitude less than 1.5 of the average amplitude can be 
safely ignored and peaks with the amplitude greater than the average 
by a factor of 2 should must be masked out since they noticeably affect 
the fringe fitting procedure and distort the estimate of the average 
phase and the amplitude. Peaks with the amplitude in a range 
[1.2, 2] of the average autocorrelation are in the border line.
It is not recommended to mask out auto-correlation at the edge of
the IFs, since during data processing <EM class="pima">PIMA</EM>
interpolates auto-correlation.
<P>

  Cross-correlation spectrum can be distorted  by external RFI, such as satellite 
radio. Hardware problem or errors in the hardware setup may cause cause a significant
drop in the amplitude or a total loss of signal either at the entire IF, or
a range of IFs, or a portion of IFs. If there is no signal in given spectral
channels, the SNR will be reduced and weak sources may not be detected. Masking out 
unwanted noise improves the SNR. Cross-correlation spectrum from narrow-band 
targets, such as masers or satellites may not have signal beyond edges of 
the bandwidth even in the absence of hardware failures.
<P>

   <EM class="pima">PIMA</EM> supports mask file specified by the keyword 
<EM CLASS="com">BANDPASS_MASK_FILE</EM>. This 
file defines four sets of values, 0 or 1, for <B>each</B> phase spectral 
channels. <EM class="pima">PIMA</EM> multiplies visibilities by the mask, 
which effectively disables spectral channels that corresponds to mask with 
value 0. The first mask affects autocorrelations, and three remaining masks 
affect cross-correlations. The second mask used used only for computation 
of bandpass, the third mask used for fringe fitting, and the fourth mask is 
used by task <EM class="task">splt</EM> for computing visibilities averaged 
over frequency and time. Usually the second, the third, and the fourth masks 
are the same, i.e. a common mask for cross-correlation is used. 
Autocorrelation and cross-correlation masks are usually different since 
different factors lead to necessity to mask auto-correlation and 
cross-correlations.
<P>

  If the mask for a given cross-correlation is zero, the corresponding visibility
is replaced with zero. If the mask of a given auto-correlation is zero, the
auto-correlation at a given spectral channel is computed by linear interpolation 
between adjacent channels, or linear extrapolation, if the masked channel is at
the edge of the IF. The corresponding cross-correlation is not affected. Very
often strong unmasked spurious signals that results in autocorrelation greater 
than 2&ndash;5 of the average level usually affect the cross-correlation as well.
Therefore, it is prudent first to mask out strong spurious signals at autocorrelation
and then check cross-correlation spectrum.
<P>

  An analyst may create the mask file by hand, but this is a tedious work.
<EM class="pima">PIMA</EM> supports so-called bandpass mask definition files that allows to specify
the spectral channels that are to be suppressed in a concise way. The bandpass
mask definition file allows to define ranges of the spectral channels  that are 
to be mask out. An analyst edits the bandpass mask definition file, converts it 
to the bandpass mask, visualizes the cross- and auto- phase and amplitude 
spectra, and repeat this procedure till a satisfactory result is produced.
<P>

  A bandpass mask definition file consists of records of variable
length. The first record identifies the format. It should always be
be <TT># <EM class="pima">PIMA</EM> BPASS_MASK_GEN  v 0.90 2009.02.05</TT>
Lines that start with '#', except the first one, are considered to be comments,
and the parser ignores them. Mask definition records consists of 8 words
separated by one or more blanks
<TT>
mmmm  STA: ssssssss  IND_FRQ: aa-bb  IND_CHN: xx-yy  ddd
</TT>
<P>

  where <TT>mmmm</TT> is the mask type: one of AUTC (autocorrelation mask),
BPAS (bandpass mask), FRNG (fringe fitting mask), SPLT (split mask), 
CROS (bandpass+fringe_fitting+split masks), ALL (all masks: 
autocorrelation+bandpass+fringe_fitting+split)
<TT>sssssss</TT> is the station name, <TT>aa</TT> is the index of 
the first IF of the range, <TT>bb</TT> is the index of the last IF of the range,
<TT>xx</TT> is the index of the first spectral channel in a given IF range and 
<TT>yy</TT> is the index of the last spectral channel in a given IF range;
<TT>ddd</TT> is disposition: ON or OFF. Station name may be substituted by 
ALL, what means the definition affects all stations.
<P>
  The first definition sets the default disposition: ON or OFF. Unless you
have  really pathological experiment and you have to disable the majority of
spectral channels, the first definition is 
<TT>ALL STA ON</TT>, what means to enable all spectral channels
The definitions are processed consecutively. Each new definition alters
the mask defined by priori definitions.

Here is an example:

<PRE>
# <EM class="pima">PIMA</EM> BPASS_MASK_GEN  v 0.90 2009.02.05
#
#  Control for bandpass mask generation for VLBI experiment BP192B3
#
#  Created on 2015.11.14_12:33:11
#
ALL    STA:   ALL         ON
#
ALL    STA:   ALL         IND_FRQ:   3-3    IND_CHN: 121-129   OFF
CROS   STA:   KP-VLBA     IND_FRQ:   1-2    IND_CHN:   1-512   OFF
AUTC   STA:   FD-VLBA     IND_FRQ:   4-4    IND_CHN: 431-436   OFF
</PRE>

  The first line identifies the format. The first non-comment line
sets the initial mask 1. The second non-comment lines disables both
autcorrelations and cross-correlations for the IF #3, spectral
channels 121 through 129. The third line disables cross-correlation
in IFs #1 and #2 (that experiment has 512 spectral channels per IF)
for station KP-VLBA. The fourth line disables autocorrelation for
FD-VLBA in spectral channels from 431 through 436 in IF #4 keeping
autocorrelation. 
  


<H3>Masking auto- and cross-correlation spectral channels</H3>

  <EM class="pima">PIMA</EM> allows to mask out specified channels of 
either auto or cross-spectrum or both. The auto-correlation spectrum 
is corrupted by the presence of internal RFI generated in the vicinity 
of the data acquisition system. Usually the internal RFI causes 
appearance of peaks in the auto-correlation spectrum. As a rule of thumb 
peaks with the amplitude less than 1.5 of the average amplitude can be 
safely ignored and peaks with the amplitude greater than the average 
by a factor of 2 should must be masked out since they noticeably affect 
the fringe fitting procedure and distort the estimate of the average 
phase and the amplitude. Peaks with the amplitude in a range 
[1.2, 2] of the average autocorrelation are in the border line.
It is not recommended to mask out auto-correlation at the edge of
the IFs, since during data processing <EM class="pima">PIMA</EM>
interpolates auto-correlation.
<P>

  Cross-correlation spectrum can be distorted  by external RFI, such as satellite 
radio. Hardware problem or errors in the hardware setup may cause cause a significant
drop in the amplitude or a total loss of signal either at the entire IF, or
a range of IFs, or a portion of IFs. If there is no signal in given spectral
channels, the SNR will be reduced and weak sources may not be detected. Masking out 
unwanted noise improves the SNR. Cross-correlation spectrum from narrow-band 
targets, such as masers or satellites may not have signal beyond edges of 
the bandwidth even in the absence of hardware failures.
<P>

   <EM class="pima">PIMA</EM> supports mask file specified by the keyword 
<EM CLASS="com">BANDPASS_MASK_FILE</EM>. This 
file defines four sets of values, 0 or 1, for <B>each</B> phase spectral 
channels. <EM class="pima">PIMA</EM> multiplies visibilities by the mask, 
which effectively disables spectral channels that corresponds to mask with 
value 0. The first mask affects autocorrelations, and three remaining masks 
affect cross-correlations. The second mask used used only for computation 
of bandpass, the third mask used for fringe fitting, and the fourth mask is 
used by task <EM class="task">splt</EM> for computing visibilities averaged 
over frequency and time. Usually the second, the third, and the fourth masks 
are the same, i.e. a common mask for cross-correlation is used. 
Autocorrelation and cross-correlation masks are usually different since 
different factors lead to necessity to mask auto-correlation and 
cross-correlations.
<P>

  If the mask for a given cross-correlation is zero, the corresponding visibility
is replaced with zero. If the mask of a given auto-correlation is zero, the
auto-correlation at a given spectral channel is computed by linear interpolation 
between adjacent channels, or linear extrapolation, if the masked channel is at
the edge of the IF. The corresponding cross-correlation is not affected. Very
often strong unmasked spurious signals that results in autocorrelation greater 
than 2&ndash;5 of the average level usually affect the cross-correlation as well.
Therefore, it is prudent first to mask out strong spurious signals at autocorrelation
and then check cross-correlation spectrum.
<P>

  An analyst may create the mask file by hand, but this is a tedious work.
<EM class="pima">PIMA</EM> supports so-called bandpass mask definition files that allows to specify
the spectral channels that are to be suppressed in a concise way. The bandpass
mask definition file allows to define ranges of the spectral channels  that are 
to be mask out. An analyst edits the bandpass mask definition file, converts it 
to the bandpass mask, visualizes the cross- and auto- phase and amplitude 
spectra, and repeat this procedure till a satisfactory result is produced.
<P>

  A bandpass mask definition file consists of records of variable
length. The first record identifies the format. It should always be
be <TT># <EM class="pima">PIMA</EM> BPASS_MASK_GEN  v 0.90 2009.02.05</TT>
Lines that start with '#', except the first one, are considered to be comments,
and the parser ignores them. Mask definition records consists of 8 words
separated by one or more blanks
<TT>
mmmm  STA: ssssssss  IND_FRQ: aa-bb  IND_CHN: xx-yy  ddd
</TT>
<P>

  where <TT>mmmm</TT> is the mask type: one of AUTC (autocorrelation mask),
BPAS (bandpass mask), FRNG (fringe fitting mask), SPLT (split mask), 
CROS (bandpass+fringe_fitting+split masks), ALL (all masks: 
autocorrelation+bandpass+fringe_fitting+split)
<TT>sssssss</TT> is the station name, <TT>aa</TT> is the index of 
the first IF of the range, <TT>bb</TT> is the index of the last IF of the range,
<TT>xx</TT> is the index of the first spectral channel in a given IF range and 
<TT>yy</TT> is the index of the last spectral channel in a given IF range;
<TT>ddd</TT> is disposition: ON or OFF. Station name may be substituted by 
ALL, what means the definition affects all stations.
<P>
  The first definition sets the default disposition: ON or OFF. Unless you
have  really pathological experiment and you have to disable the majority of
spectral channels, the first definition is 
<TT>ALL STA ON</TT>, what means to enable all spectral channels
The definitions are processed consecutively. Each new definition alters
the mask defined by priori definitions.

Here is an example:

<PRE>
# <EM class="pima">PIMA</EM> BPASS_MASK_GEN  v 0.90 2009.02.05
#
#  Control for bandpass mask generation for VLBI experiment BP192B3
#
#  Created on 2015.11.14_12:33:11
#
ALL    STA:   ALL         ON
#
ALL    STA:   ALL         IND_FRQ:   3-3    IND_CHN: 121-129   OFF
CROS   STA:   KP-VLBA     IND_FRQ:   1-2    IND_CHN:   1-512   OFF
AUTC   STA:   FD-VLBA     IND_FRQ:   4-4    IND_CHN: 431-436   OFF
</PRE>

  The first line identifies the format. The first non-comment line
sets the initial mask 1. The second non-comment lines disables both
autcorrelations and cross-correlations for the IF #3, spectral
channels 121 through 129. The third line disables cross-correlation
in IFs #1 and #2 (that experiment has 512 spectral channels per IF)
for station KP-VLBA. The fourth line disables autocorrelation for
FD-VLBA in spectral channels from 431 through 436 in IF #4 keeping
autocorrelation. 
  
<H3> Creation complex bandpass in the inspection mode</H3>

  Task <EM class="task">bpas</EM> compute complex band-pass. This task 
supports 4 modes: <EM class="val">INSP</EM> (inspection), 
<EM class="val">INIT</EM> (initial), <EM class="val">ACCUM</EM> 
(accumulation), and <EM class="val">FINE</EM>. Modes <EM class="val">INIT</EM>
and <EM class="com">INSP</EM> differs only by the generated output: 
<EM class="task">bpas</EM> in <EM class=val">INSP</EM> mode generates plots, 
while <EM class="task">bpas</EM> in INIT mode does not.
<P>

  Task <EM class="task">bpas</EM> takes as input result of fringe fitting. 
In general, it is not required to have fringe fitting results for all 
observations, although it is desirable. <EM class="pima">PIMA</EM> will 
find <TT>n</TT> observations with the highest SNR at each baseline with 
the reference station and will compute the complex bandpass using these 
observations. <EM class="pima">PIMA</EM> uses one observation with the 
highest SNR per baseline in <EM class="val">INIT</EM> or 
<EM class="val">INSP</EM> mode. It may happen that just the observation with 
the highest SNR is affected by RFI or has another problems. In such a case 
affected observation can be added into the exclude list. 
<P>

  In a case of dual-polarization observations two bandpasses are computed:
for RR polarization  and for difference LL minus RR polarization. The second
bandpass is called polarization bandpass. The main bandpass is RR for 
single-polarization RR data, LL for single-polarization LL data, and
RR for dual-polarization data. In order to compute both, main RR bandpass 
and polarization bandpasses, task <EM class="task">bpas</EM> should be 
executed with <EM class="com">POLAR:</EM> <EM class="val">I</EM>.
<P>

  Wrapper <EM class="wrap">pf.py</EM> simplifies generation of the bandpass. 
It checks exclusion file <TT>VVVVV/EEE/EEE_B_bpas_obs.exc</TT>. If it does 
not find such a file, the wrapper creates an empty file with a comment line. 
It supports option <EM class="com">-insp</EM> that overrides value of 
<EM class="com">BPS.MODE</EM>.

<PRE>
 Usage: <EM class="wrap">pf.py</EM> <EM <EM class="val">exp band obs</EM> <EM class="com">[-insp]</EM>
</PRE>

  When <EM class="pima">PIMA</EM> task <EM class="com">bpas</EM> is invoked in 
the <EM class="val">INSP</EM> mode, <EM class="pima">PIMA</EM> runs a cycle over
baselines with the reference station and computes amplitude and phase bandpasses
for an observation with the highest SNR among selected observations of each 
baseline  with the referenced station. It displays two plots per baseline: 
amplitude plot and phase plot. An amplitude plots shows three function: 
autocorrelation (red), cross-correlation normalized to unity (blue) and the 
bandpass (green). The phase plot shows residual phase (blue) and phase bandpass 
(green).
<P>

  When computing bandpass, <EM class="pima">PIMA</EM> re-runs fringe fitting 
for the selected observation. Blue lines in the amplitude and phase plots show 
just residual amplitudes and phases from that fringe fitting. Then a smooth 
curve is fitted to the residuals. <EM class="pima">PIMA</EM> supports two 
algorithms: fitting with a smoothing spline of the 3rd degree over <TT>n</TT> 
equi-distant knots or with a Legendre polynomial of degree <TT>b</TT>. 
The smoothing methods should be the same for phase and amplitude, but the 
degree of the Legendre polynomial or the number of knots for the spine can 
be different for amplitude and phase.
<P>
 
  Smoothing mode is defined by keyword <EM CLASS="com">BPS.INTRP_METHOD</EM>. 
It can take values <EM CLASS="val">SPLINE</EM>, <EM CLASS="val">LEGENDRE</EM>, 
or <EM CLASS="val">LINEAR</EM>. Phase initial bandpass is the smoothed 
model bandpass with opposite sign. The phase bandpass is normalized to have 
the mean phase over the <I>band</I> zero. <EM class="pima">PIMA</EM> will 
unwrap phase if phase bandpass exceeds &pm;&pi;/2. Amplitude bandpass is 
normalized to unity. If <EM CLASS="com">BPS.NORML:</EM> IF, then the amplitude 
bandpass is analyzed over each IF separately. If <EM CLASS="com">BPS.NORML</EM>: BAND,
then the amplitude bandpass is normalized over the band. Which mode to use?
That depends on hardware. If system temperature is measured for entire band, 
then normalization should be made over the band. If system temperature is measured
at each IF (or pairs of IFs) individually, than normalization over IF should
be used. Autocorrelation is always normalized over IF.
<P>

  <EM class="pima">PIMA</EM> task <EM class="task">bpas</EM> in the inspection 
mode displays two plots per baseline:
amplitude bandpass and phase bandpass. Reading these plots is an important skill.
An analyst should identify spikes in autocorrelation amplitudes and mask them
out. To identify a spike in autocorrelation, first set color index 3 by hitting 
<B>C</B> and <B>3</B>, then move the cursor close to the spike and hit 
<B>LeftMouse</B> button. Dump file <TT>SSSSS/pima/EEE.frq</TT> helps to identify 
an IF/channel indices. Using this information, an analyst adds a record in the 
mask definition file. There is no firm rule when a spike should be mask out.
Usually spikes with amplitudes greater than 2 should be mask out, and those 
with amplitudes in a range [0.8, 1.2] are kept. After all spikes in 
autocorrelation are mask out, a mask should be generated from the mask 
definition file using task <EM class="task">bmge</EM>. Task <EM class="task">bmge</EM> requires qualifier mask_gen with 
the value mask definition file. After than inspection of autocorrelation 
amplitudes should be repeated. <B>NB:</B> Amplitude of masked 
autocorrelation is set to zero. If necessary, mask definition file should be 
edited, mask re-generated, and the procedure repeated.
<P>

  After cleaning autocorrelation spectrum, cross correlation should be cleaned.
Several situations are rather common:
<OL>
   <LI> There is no signal in one or more IFs mainly due to hardware error or
        errors in the setup. These IFs should be masked out entirely.
        </LI><P>

   <LI> Cross-correlation amplitude in one or more IF is lower than in others.
        These IFs <I>may be</I> masked out depending how strongly the amplitude
        is down. If the amplitude is lower by a factor of 4&ndash;6, such an IF
        brings more noise than signal and probably should be mask out. Masking
        out an IF with the amplitude less than 1.5 times will degrade the SNR
        and deteriorate the result. Amplitude loss in a range 1.5&ndash;5 is 
        the border line.
        </LI><P>

   <LI> A significant portion of an IF has low amplitude. This may be caused 
        by RFI or the receiver bandpass shape. It is recommended to 
        masked out that portion of the bandpass.
        </LI><P>

   <LI> Amplitude at the edge of each IF is low. This is the most common
        situation. This is caused by the hardware. A general recommendation
        to mask out a portion of the band that is below some threshold
        in a range of 0.05%ndash;0.2. 
        </LI><P>
</OL>

A hint: task <EM class="task">bpas</EM> in the inspection mode processes 
baselines in the alphabetic order. If a certain station requires heavy 
editing the bandpass generation file, you can run the task with 
<EM class="com">OBS</EM>: num_obs qualifier, there num_obs is the index 
of the observation with the highest SNR at the baseline of interest.
<P>

  Task <EM class="task">bpas</EM> supports keyword 
<EM CLASS="com">BPS.AMP_MIN</EM> that defines the threshold on the fringe 
amplitude as the share of mean amplitude over the IF. Spectral channels with 
the amplitude threshold below <EM class="com">BPS.AMP_MIN</EM> are ignored 
by task <EM class="task">bpas</EM>. The bandpass to these channels is obtained 
by extrapolation from those channels that are in use. This may be useful
if the bandpass has strong changes at channels with low amplitude,
since in that case smoothing with Legendre polynomial and spline may
not be robust.
<P>

   Phase may become too noisy in experiment with high spectral resolution.
In that case the residuals should be coherently averaged. The number 
of spectral channels averaged within an individual segment is defined
by keyword. Value <EM class="val">1</EM> stands for no averaging. A balance 
between averaging and spectral resolution should be maintained. From
one hand strong averaging (high value of <EM class="com">BPS.MSEG_ACCUM</EM>)
results in less random noise in phase. From the other hand, averaging reduces 
spectral resolution and our ability to model the system response as a function
of frequency. Scatter greater than 1&ndash;2 rad may result in a failure to 
resolve phase ambiguity across an IF, which will lead to a wrong result. 
A general guideline is to select such averaging that the scatter of residual 
phases with respect to a smooth line be in a range of 0.05&ndash;0.2 rad for 
the sources used for bandpass computation.
<P>

  Interpolation of the bandpass is important. In the simplest form the bandpass
is just reciprocal to the normalized complex cross-correlation function of the
observation with the highest SNR at a given baseline. If the SNR of that 
observation were infinitely high, this would have been the optimal approach.
However, when we <I>apply</I> the bandpass computed by inversion of the 
normalize dd complex cross-correlation function of an observation with
finite SNR, we propagate the noise of that observation to other observations,
which results in an increase of the total noise. To alleviate undesirable
noise propagation, we 1) use more than one observation for computing
band pass, 2) coherently average <TT>n</TT> adjacent visibilities; 
3) smooth the bandpass with polynomial or splines. 
<P>

  The choice of the magnitude of coherent averaging and the degree of 
the polynomial or the number of spline knots depends both on the SNR
and the number of spectral channels in the IF. The higher SNR of the
observations used for bandpass computation, the better, although the 
quantitative measure of whether a given SNR is high enough is rather
subjective. Observations with SNR 200&ndash;2000 allows to compute
a rather reliable bandpass with the number of spline knots 
7&ndash;20 (In general Legendre polynomials of degree  higher than 
5&ndash;7 are undesirable since they are prone to end up with bandpass
of wiggling shape like a dinosaur's spine).
<P>

A wise principal investigator will insert enough strong
calibrators to make computation of the bandpass robust, but sometimes
either the PI did not think well, or observations of strong calibrators
failed, or their were not possible, for instance for space VLBI.
In that case we have to compute bandpass using weak calibrators.
When observations with SNR in a range 30&ndash;100 are used care must
be taken to generate a robust bandpass. First, it should be checked 
that the scatter of the residual phases of the observations used for 
bandpass compilation is smaller &pi;/3&ndash;&pi;/6^ndash and phase
ambiguities can be reliable resolved. If an error in ambiguity 
resolution will happen, it will strongly poison a bandpass: such 
a bandpass, when applied, will degrade the SNR, not improve it. 
To mitigate phase ambiguity resolution, the residual cross-correlation
is coherently averaged (keywords <EM class="com">BPS.MSEG_ACCUM</EM> and
<EM class="com">BPS.MSEG_FINE</EM>). Second, the degree of the smoothing
polynomial or the number of spline knots is reduced.
<P>

  Finally, when the bandpass has to be computed using the very weak 
observations with the SNR 7&ndash;20, <EM class="com">BPS.INTRP_METHOD:</EM>
<EM class="val">LINEAR</EM> is used as the last resource. 
This mode requires <EM class="com">BPS.MSEG_ACCUM</EM> and 
<EM class="com">BPS.MSEG_FINE</EM> be equal to half of the number of 
spectral channels and 
<EM class="com">BPS.DEG_AMP:</EM> <EM class="val">0</EM> and 
<EM class="com">BPS.DEG_PHS:</EM> <EM class="val">1</EM>.
In this mode the cross-spectrum is coherently averaged to two points per IF.
The amplitude bandpass is computed as the IF-averaged level. The phase
bandpass is computed as a linear function over two points. This mode 
is the most robust, but it does not model the more grained shape
of the bandpass. This omission is not essential for low-SNR observations.
According to the reciprocity principle omission in the data reduction 
of a quantity that cannot be reliably determined from observations cannot
significantly degrade goodness of the fit. From the other hand, using
<EM class="com">BPS.INTRP_METHOD:</EM> <EM class="val">LINEAR</EM> for
experiments with higher SNR observations may results in worse result with
respect to <EM class="com">BPS.INTRP_METHOD:</EM> <EM class="val">LEGENDRE</EM> 
or <EM class="val">SPLINE</EM>. The natural low limit of observations used
for bandpass generation in <EM class="com">BPS.INTRP_METHOD:</EM> 
<EM class="val">LINEAR</EM> mode is the detection limit. Inadvertent
inclusion of a non-detection to the list of observations used for bandpass
generation will significantly degrade the bandpass. Better use no bandpass
than a wrong bandpass.
<P>

  When the analyst is satisfied with plots that task <EM class="task">bpas</EM> 
generates in the inspection mode, an analyst runs <EM class="task">bpas</EM> 
task in the non-interactive mode to generate the final bandpass. There are 
three modes for computation of the bandpass: <EM CLASS="val">INIT</EM>, 
<EM CLASS="val">ACCUM</EM>, and <EM CLASS="val">FINE</EM>. 
<EM class="pima">PIMA</EM> computes the residual visibilities averaged over 
time with parameters of fringe fitting applies. In the <EM class="val">INIT</EM> 
mode <EM class="pima">PIMA</EM> picks up for each baseline the observation 
with the highest SNR among the observations with the reference stations that are 
subject of filter <EM CLASS="com">OBS</EM>, <EM CLASS="com">INCLUDE_OBS</EM>, and 
<EM CLASS="com">EXCLUDE_OBS</EM> keywords. It normalizes 
the amplitude to have the mean value to unity either over the IF or over 
the band depending on <EM CLASS="com">BPS.NORML</EM> keyword. The residual 
phase is normalized to have mean value and mean rate to zero over the bandwidth 
regardless of the value of <EM CLASS="com">BPS.NORML</EM>. 
<EM class="pima">PIMA</EM> smooths the residual phases and residual amplitudes 
and the inverts them: flips the sign of phase band pass, replaces the residual
amplitude with the quantity reciprocal to that for each spectral channel, and 
combines them to form array of complex numbers. These quantities are called 
initial complex bandpass. 
<P>

  Initial bandpass is computed using only one observation per baseline.
If an analyst selected <EM CLASS="cal">BPS.MODE:</EM> <EM class="val">INIT</EM>,
the task <EM class="task">bpas</EM> stops here. If a user selected 
<EM class="val">ACCUM</EM> or <EM class="val">FINE</EM> mode 
<EM class="pima">PIMA</EM> selects N observations per baseline with the 
highest SNR beyond that that was used in the <EM class="val">INIT</EM>
mode. It applies the initial bandpass determine residual phases and
amplitudes and averages them out. It reverses sign of residual phases,
replaces normalized residual amplitudes, combines them in the array of 
complex numbers and multiplies it by the initial bandpass. The result
is called accumulated bandpass. The number of observations per baseline
used for computation of the accumulation bandpass is controlled by
two parameters: <EM CLASS="com">BPS.NOBS_ACCUM</EM> and 
<EM CLASS="com">BPS.SNR_MIN_ACCUM</EM>. <EM class="pima">PIMA</EM> will 
select up to <EM CLASS="com">BPS.NOBS_ACCUM</EM> observations for each 
baseline with the highest SNR, not counting the observation used for 
computation of the initial bandpass, provided they SNR is 
<EM CLASS="com">BPS.SNR_MIN_ACCUM</EM> or above. The advantage of the 
accumulation bandpass is that it is unweighted average over N observations, 
and therefore, it accounts to some degree bandpass variation. If a user 
selected <EM CLASS="val">ACCUM</EM> mode <EM class="pima">PIMA</EM> task 
<EM class="task">bpas</EM> stops here.
<P>

  If a user chooses <EM CLASS="val">FINE</EM> bandpass computation mode, 
<EM class="pima">PIMA</EM> selects K observations per baseline with the 
highest SNR beyond that that was used in the <EM CLASS="val">INIT</EM> mode. 
It applies accumulation bandpass and forms the system of linear equations 
for adjustment  to parameters of the model for the phase bandpass 
and logarithm of the amplitude bandpass, i.e. either coefficients of 
Legendre polynomial or B-spline. It solves the system using weighted
least squares with weights proportional to fringe amplitude. Then it
computes residual phases and amplitude corrections, computes their
statistics, and if the statistics exceed the specified threshold, it
discards the observations with the greatest residual and repeats 
computation until either the statistics become lower than the 
threshold or the number of rejected observations per baseline reaches
the specified limit. 
<P>

   Keyword <EM CLASS="com">BPS.SNR_MIN_FINE</EM> specifies the minimum SNR. 
Observations with SNR below that limit are not used by <EM class="pima">PIMA</EM> 
for bandpass computation in the <EM class="val">FINE</EM> mode. Keyword 
<EM CLASS="com">BPS.NOBS_FINE</EM> specifies the number of observations
with the highest SNR per baseline that <EM class="pima">PIMA</EM> selects 
for bandpass computation in the <EM class="val">FINE</EM> mode, provided their SNR 
is no less than <EM CLASS="com">BPS.SNR_MIN_FINE</EM>. If a given observation has 
residual statistics above the threshold, <EM class="pima">PIMA</EM> will discard 
it provided the number of remaining used observations is no less than 
<EM CLASS="com">BPS.MINOBS_FINE</EM>. This mechanism prevents rejection of 
too many observations.
<P>

  After performing the first iteration of LSQ adjustment, <EM class="pima">PIMA</EM> 
computes for each IF weighted rms of residual phases and normalized residual 
amplitudes. Then <EM class="pima">PIMA</EM> finds an observation with maximum 
phase and maximum amplitude residual. If the rms of phase residual exceeds 
<EM CLASS="com">BPS.PHAS_REJECT</EM> radians, that observation is marked for 
rejection. If the rms of normalized amplitude residuals exceeds 
<EM CLASS="com">BPS.AMPL_REJECT</EM>, that observation is marked for rejection. 
If the number of used observations still exceeds 
<EM CLASS="com">BPS.MINOBS_FINE</EM>, the observation is rejected, and the next 
iteration runs. <EM class="pima">PIMA</EM> maintains two counters of used 
observations: for the phase bandpass and for the amplitude bandpass. An observation 
may be rejected for amplitude bandpass but kept for phase bandpass, or vice versus,
or rejected for both amplitude and phase bandpasses.
<P>

  <EM class="pima">PIMA</EM> task <EM class="task">bpas</EM> prints valuable 
statistics when <EM class="com">DEBUG_LEVEL:</EM> <EM class="val">3</EM> or higher. 
An analyst should always examine it.
Lines that starts with "BPASS Removed" are especially important. If there are
many rejected observations at a given baseline, especially if their phase or
amplitude rms of residuals is large, an analyst  should examine these 
observations: to run a trial fringe fit and look at residuals. Bad observations
may skew bandpass evaluation, so it may be necessary to examine residuals
with and without applying bandpass (BANDPASS_USE: NO). One of the reasons of
computing bandpass in FINE mode is to find observations with large residual
phases or residual amplitudes.
<P>

  It may happen that a fraction of high SNR observations are affected by 
hardware failure or RFI. If <EM class="task">bpas</EM> task does not reject 
them, they skew the estimate of bandpass. There is another mechanism to get 
rid of such observations for bandpass computation: to put them in the exclude 
list. <EM class="pima">PIMA</EM> wrapper <EM class="wrap">pf.py</EM> 
automatically checks file <TT>VVVVV/EEE/EEE_B_bpas_exc.obs</TT>. If it exists, 
it adds option EXCLUDE_OBS:  <TT>VVVVV/EEE/EEE_B_bpas_exc.obs</TT>,  
i.e. excludes them from participation in bandpass computation.
<P>

  <EM class="pima">PIMA</EM> task <EM class="task">bpas</EM> assumes bandpass is stable. It may happen 
one or more jumps, f.e. due to power failure. In that case 
<EM class="pima">PIMA</EM> will reject many observations. At the moment, 
<EM class="pima">PIMA</EM> does not have a capability to accommodate a jump. 
A workaround is to process two portions of the experiment separately by 
specifying observation lists using <EM CLASS="com">INCLUDE_OBS_FILE</EM>, 
<EM CLASS="com">EXCLUDE_OBS_FILE</EM> or <EM CLASS="com">OBS</EM> keywords. 
If a given station has more than 2&ndash;3 jumps in bandpass, it should be 
discarded and station staff should be alerted.
<P>

  If there are many rejected observations an analyst may a) mask out bad
channels b) add offending observations to the exclude list; c) exclude
a list of observations; d) discard a station; e) ignore it.
<P>

  In a case of dual-polarization data when <EM class="com">POLAR:</EM> 
<EM class="val">I</EM> is specified, the procedure is repeated twice: 
first for the RR polarization bandpass second for the LL polarization 
with respect to the RR polarization data. Therefore, a trial fringe fit 
with bandpass applied should run three times: with RR polarization, 
with LL polarization, and with I polarization. If the polarization 
bandpass was computed perfectly, then SNR at I polarization
should be
<TT style="font-size: 130%">&Sqrt;</TT>&nbsp;<span style="text-decoration: overline; vertical-align: +15%; margin-left: -0.4em";> 
       SNR<sup>2</sup><sub><tt>RR</tt></sub> + 
       SNR<sup>2</sup><sub><tt>LL</span></tt></sub> 
SNR reduction 2&ndash;5% with respect to the expression above is rather common,
though if the SNR at I polarization is more than 10% worse, this indicates
a problem that should be investigated.
<P>

  A general recommendation is to run trial fringe fitting for 5&ndash;7 
observations that are marked as "removed" in the log file of 
<EM class="task">bpas</EM> task with an without bandpass applied in order to 
familiarize with the data. If fringe plots look satisfactory, the next step: 
fringe fitting in the fine mode should be done. Otherwise, masking, deselection 
of bad observations, phase calibration disabling/enabling should be repeated. 
NB: computation of bandpass should be repeated if a) bandpass or phase cal 
bandpass mask was changed or b) treatment of phase calibration was changed.

<A NAME="fine"> 
<H2> Running fine fringe fitting </H2>

   Fine fringe fitting is the main task. During coarse fringe fitting, the fine
fringe search procedure is disabled in order to speed up the process, and the 
bandpass was not applied. During fine fringe search this simplification is lifted.
<P>

   <EM class="pima">PIMA</EM> task  <EM class="task">frib</EM> performs fringe 
fitting. Wrapper <EM class="wrap">pf.py</EM> is called as

<PRE>
 Usage: <EM class="wrap">pf.py</EM> <EM <EM class="val">exp band fine</EM>
</PRE> 

   <EM class="pima">PIMA</EM> task  <EM class="task">frib</EM> creates two ascii 
output files defined in keywords <EM CLASS="com">FRINGE_FILE</EM> and 
<EM CLASS="com">FRIRES_FILE</EM>. The first file keeps results of fringe fitting 
and it is used  by other tasks. The latter file with fringe fitting residuals is 
for informational purposes only. 
<P>

   NB: wrapper <EM class="wrap">pf.py</EM> by default overwrites the files with 
fringe results if it exists. Wrapper option -keep prevents overwriting the file 
with fringe results and fringe residuals specified in the control file. 
<EM class="pima">PIMA</EM> tasks that reads results of fringe fitting, f.e. 
<EM class="task">mkdb</EM> or <EM class="task">splt</EM>, processes the fringe 
file sequentially. If there is more than one record for a given observation, 
the latest record takes the precedence. 
<P>

  There is a number of parameters that controls fringe fitting.
<UL>
    <LI> Keyword <EM CLASS="com">FRIB.SEARCH_TYPE</EM> is always 
         2FFT that means a two-dimensional Fast Fourier Transform  runs at 
         the coarse fringe fitting step. 
         </LI><P>

    <LI> The visibility data are sampled at a uniform grid with a step over time 
         and frequency. The steep over frequency is equal to the spectral 
         resolution times <EM CLASS="com">FRIB.OVERSAMPLE_MD</EM>. The step over 
         time is equal to the accumulation period length (time resolution) times 
         <EM CLASS="com">FRIB.OVERSAMPLE_RT</EM>. When oversampling factor 1 is 
         used the amplitude estimated during the coarse fringe fitting step may 
         be underestimated by a factor of 2.4 and a weak source may be missed. When the 
         oversampling factors are 4, the maximum amplitude underestimation during 
         coarse fringe fitting step is only 5%. Therefore, it is recommended to 
         use <EM CLASS="com">FRIB.OVERSAMPLE_MD</EM>: 4 and 
         <EM CLASS="com">FRIB.OVERSAMPLE_RT:</EM> 4. <EM class="pima">PIMA</EM> pads grid
         elements that do not have visibility data with zeroes.
         </LI><P>

    <LI> <EM class="pima">PIMA</EM> uses library FFTW for performing two-dimensional multi-threaded
         FFT. Library FFTW requires some customization in order to reach maximum
         performance. It uses configuration file called "wisdom file" in FFTW 
         documentation. This configuration file should be created before running
         <EM class="pima">PIMA</EM>. Package fourpack that is required for building <EM class="pima">PIMA</EM> contains
         program create_fftw_plan.

<PRE>
Usage: create_fftw_plan <method> <num_threads> <request_file> <plan_file> 
</PRE>

         where method is one of <TT>MEASURE</TT> of <TT>PATIENT</TT>, 
         <TT>num_threads</TT> is the number of threads, request_file
         is the file with dimension definitions and plan_file is the output
         configuration file. <EM class="pima">PIMA</EM> supplies two configuration files
         pima_wis_big.inp  and pima_wis_small.inp . They can be found in 
         $PIMA_DIR/share/pima/ directory, where PIMA_DIR is the environment
         variable of the directory where <EM class="pima">PIMA</EM> has been 
         installed. It is suggested 
         to use pima_wise_big.inp unless you have less than 12 Gb memory.
         In that case you should use pima_wise_small.inp, but you will not
         be able to process efficiently wide field VLBI experiments with high 
         spectral and temporal resolution. FFTW configuration file depends
         on the number of threads. If you generated the FFTW configuration
         file for N threads, but run <EM class="pima">PIMA</EM> with K threads, the configuration
         file will not be used. <EM class="pima">PIMA</EM> will run, but much 
         slower (a factor of 2&ndash;5). Therefore you have to create several 
         plans files for different number of threads. Usually, you use the same 
         number of threads as the number of cores, but you may want to reduce 
         the number of threads if you run <EM class="pima">PIMA</EM> on a busy 
         server). FFTW supports several methods for computing the best  
         configuration file. Method <TT>MEASURE</TT> is recommended. Method 
         <TT>PATIENT</TT> is supposed to improve performance, but it may take 
         several days to compute it.

         Examples:

<PRE>
         create_fftw_plan MEASURE 1 $PIMA_DIR/share/pima/pima_wis_big.inp 
                          $PIMA_DIR/share/pima/pima_big_measure_1thr.wis

         create_fftw_plan MEASURE 12 $PIMA_DIR)/share/pima/pima_wis_big.inp 
                          $PIMA_DIR/share/pima/pima_big_measure_12thr.wis
</PRE>

         <EM class="pima">PIMA</EM> keyword <EM CLASS="com">FFT_CONFIG_FILE</EM> 
         defines the FFTW configuration file.
         Keyword <EM CLASS="com">FFT_METHOD</EM> defines the method <EM>that was used 
         for generation of that file</EM> (<TT>MEASURE</TT> or <TT>PATIENT</TT>). 
         Keyword <EM CLASS="com">NUM_THREADS</EM> sets the number of threads that 
         <EM class="pima">PIMA</EM> uses for FFTW and some other parallel operations. 
         The FFTW configuration file should be generated with the same number of 
         threads and the same FFTW method, <B>otherwise <EM class="pima">PIMA</EM> 
         performance will be seriously degraded</B>.
         </LI><P>
   
    <LI> After computing two-dimension Fourier transform of visibilities,
         <EM class="pima">PIMA</EM> searches for a maximum in the result of  the transform.
         There are for keywords that define the rectangular search window.
         Keywords <EM CLASS="com">FRIB.DELAY_WINDOW_CENTER</EM> and 
         <EM CLASS="com">FRIB.RATE_WINDOW_CENTER</EM>
         define the center of the window. Units are seconds for delay
         window and dimensionless for delay rate. Keywords 
         <EM CLASS="com">FRIB.DELAY_WINDOW_WIDTH</EM>
         and <EM CLASS="com">FRIB.RATE_WINDOW_WIDTH</EM> defines the 
         <B>semi-width</B> of the search window with respect to the center. 
         The total width is twice wider over each dimension. A negative number
         sets the search window to the total length of the transform over that 
         dimension. For example, <EM CLASS="com">FRIB.DELAY_WINDOW_WIDTH</EM>: 
         <EM class="val">-1</EM> and 
         <EM class="com">FRIB.RATE_WINDOW_WIDTH</EM>: <EM class="val">-1</EM>
         means to search for fringes in the entire space that is defined as 
         1/spectral_resolution and F<sub>ref</sub>/observation_duration where 
         F<sub>ref</sub> is the reference frequency.
         <P>
  
         If you do not know group delay and delay rate of your observation, you
         need to search for fringes in the entire area of the Fourier transform.
         This is a usual situation at the first iteration of data processing.
         After completion of the first iteration, you may be able to  predict 
         group delay and phase delay rate. In that case you may want to restrict
         the search window and re-run fringe fitting with a narrow window. This
         procedure is called re-fringing. Re-fringing with a narrow window is 
         usually done for two reasons: a) to guide <EM class="pima">PIMA</EM> to 
         pick up the main 
         peak of the averaged visibilities that may appear to have a lower amplitude
         than the secondary peaks due to phase noise; b) to detect weaker sources.
         The probability of a falls detection at a given SNR is less when the search
         is done in the narrow window. The gain in the detection limit can reach
         30%.
         </LI><P>

    <LI> There are several keywords that affect amplitude but do not affect
         estimation of group delay an phase delay rate. Keyword 
         <EM class="com">FRIB.AUTOCORR_CALIB</EM> defines the algorithm for 
         autocorrelation normalization. A recommended choice is 
         <EM class="val">SQRT_MEA</EM>, which means to divided the cross 
         correlation by the square root of the products of mean autocorrelation
         across each IF after applying a digitization correction. If a user
         want to maintain compatibility with AIPS, value 
          <EM class="val">SQRT_KOG</EM> can be used. It differs from 
         <EM class="val">SQRT_MEA</EM> by the algorithm for digitization
         correction. From the point of view of <EM class="pima">PIMA</EM> 
         developer, <EM class="val">SQRT_KOG</EM> algorithm is incorrect, 
         but the differences are usually in a range of 0.5&ndash;3%, which 
         is insignificant.
<P>
         Keyword <EM class="com">FRIB.AMPL_FUDGE_TYPE</EM> controls fudge 
         factor correction. Supported values are <EM class="val">VLBA</EM>, 
         <EM class="val">KOGAN</EM>, <EM class="val">DIFX</EM> and 
         <EM class="com">NO</EM>. If your experiment has been correlated by 
         the <B><I>hardware</I></B> NRAO correlator, you should specify either
         <EM class="val">VLBA</EM> or <EM class="val">KOGAN</EM>. Then 
         a specific fudge factor to take into account register saturation 
         in the hardware correlator is applied. Basically you have to tell 
         <EM class="pima">PIMA</EM> your data have been processed with the 
          hardware correlator since there is no reliable way to learn it
         from the data themselves. The difference between is 
         <EM class="val">VLBA</EM> and <EM class="val">KOGAN</EM> is that 
         in the latter case all weights are considered to be 1 when 
         correction is applied. Values <EM class="val">DIFX</EM> or 
         <EM class="val">NO</EM> mean no fudge factor should be applied.
<P>
         Fringe amplitude decays linearly with an increase residual group
         delay. The attenuation factor reaches 0.5 when the residual group 
         delay reaches a quantity reciprocal to the spectral resolution.
         <EM class="com">FRIB.AMPL_EDGE_WINDOW_COR</EM> keyword instructs 
         <EM class="pima">PIMA</EM> to compensate this attenuation. You should 
         specify its value USE, unless you have a strong argumentation against 
         it.
<P>
         Keyword <EM class="com">FRIB.AMPL_EDGE_BEAM_COR</EM> instructs 
         <EM class="pima">PIMA</EM> to apply (<EM class="val">YES</EM>) or
         not to apply (<EM class="val">NO</EM>) a correction for beam 
         attenuation. It is assumed you know source positions with accuracy 1" 
         or better <B>and</B> used this a priori coordinates in the catalogue 
         when you loaded <EM class="pima">PIMA</EM>. <EM class="pima">PIMA</EM> 
         has a table with measured beam factors for ATCA and VLA antennas. For 
         all other antennas it scales the VLA beam pattern using antenna 
         diameter. It is recommended to use value <EM class="val">YES</EM>.
<P>
         <EM class="pima">PIMA</EM> discards visibilities with low weights. Two 
         keywords <EM class="com">FRIB.AUTOCORR_THRESHOLD</EM> and 
         <EM class="com">FRIB.AUTOCORR_THRESHOLD</EM> specify
         the low threshold for autocorrelation and cross-correlation
         weights. Typically, normal weights are 1 and the thresholds 
         0.2 are recommended. Weights below that threshold usually 
         means failures. However, sometimes weights for normal visibilities
         are low. In that case thresholds 0.2 may force <EM class="pima">PIMA</EM> 
         to discard all the data. In that case an analyst may try to reduce values
         of keywords <EM class="com">FRIB.AUTOCORR_THRESHOLD</EM> and 
         <EM class="com">FRIB.AUTOCORR_THRESHOLD</EM>.
<P>      
         Keyword <EM class="com">FRIB.NOISE_NSIGMA</EM> controls computation of 
         the noise. After fringe fitting <EM class="pima">PIMA</EM> selects randomly 
         32768 samples of the Fourier transform, orders them in decreasing their 
         amplitudes, and computes the rms. Then it runs iterative procedure of 
         excluding samples with amplitudes greater than 
         <EM class="com">FRIB.NOISE_NSIGMA</EM>. After excluding
         each sample, the rms is updated. Usually, value <EM class="val">3.5</EM> 
         is optimal.
         </LI> <P>
 
    <LI> <EM class="pima">PIMA</EM> checks the value of the keyword 
         <EM class="com">FRIB.SNR_DETECTION</EM> and sets 
         and advisory flag whether the was a detection. Depending on a size
         of the fringe search window, the detection limit is in a range of
         <EM class="val">4.8&ndash;5.8</EM> (less for a smaller window). 
         NB: <EM class="pima">PIMA</EM> does not check, whether the source has 
         been actually detected, it only checks whether the SNR was less of 
         greater than the specified threshold.
<P>
         <EM class="pima">PIMA</EM> supports several algorithms of fine fringe 
         search specified by keyword <EM class="com">FRIB.FINE_SEARCH</EM>. 
         The most commonly used algorithm is <EM class="val">LSQ</EM>.
         <EM class="pima">PIMA</EM> adjusts phase delay rate, group delay, and 
         group delay rate using least squares with both additive and 
         multiplicative reweighting. Method <EM class="val">ACC</EM> performs 
         a similar procedure, but it adjusts phase delay
         acceleration instead of group delay rate. This mode is used for a case
         when a priori station position has a very large uncertainty that causes
         a significant quadratic term in phase. This happens mainly when one of 
         the elements of the interferometer is in space, f.e. RadioAstron.
         Method <EM class="val">PAR</EM> that adjusts group delay and phase 
         delay rate using parabolic fitting is used mainly for a coarse fringe 
         search.
         </LI><P>

    <LI> <EM class="pima">PIMA</EM> task  <EM class="task">frib</EM> can 
         generate four types of plots. There are four keywords that controls 
         the way how <EM class="pima">PIMA</EM> generates these plots: 
         <EM class="com">FRIB.1D_RESFRQ_PLOT</EM>, 
         <EM class="com">FRIB.1D_RESTIM_PLOT</EM>, 
         <EM class="com">FRIB.1D_DRF_PLOT</EM>, and 
         <EM class="com">FRIB.2D_FRINGE_PLOT</EM>. 
         These keywords can take one of six values:
         <OL>
             <LI><EM class="val">NO</EM> &mdash; do not generate a plot;
                 </LI>
             <LI><EM class="val">XW</EM> &mdash; to display the plot in the current X11
                 window;
                 </LI>
             <LI><EM class="val">PS</EM> &mdash; to generate a plot in Postscript format;
                 </LI>
             <LI><EM class="val">GIF</EM> &mdash; to generate a plot in GIF format;
                 </LI>
             <LI><EM class="val">SAV</EM> &mdash; to generate a plot in DiaGI format.
                 The plot can be re-displayed with command diagi_rst that is
                 a part of petools package.
                 </LI>
             <LI><EM class="val">TXT</EM> &mdash; to generate a table with columns argument
                 a value in a plain ascii format.
                 </LI>
        </OL>
        A plot is written in directory <TT>SSSSS/EEE_fpl</TT>.
<P>        
        A 1D-plot of amplitudes and residual phases versus frequency is 
        controlled by the keyword <EM class="com">FRIB.1D_RESFRQ_PLOT</EM>. 
        The residuals are coherently averaged over 
        <EM class="com">FRIB.1D_FRQ_MSEG</EM> spectral channels. Averaging is 
        not needed for high SNR observations (i.e. 
        <EM class="com">FRIB.1D_FRQ_MSEG</EM> should be set to 
        <EM class="val">1</EM>), but may be needed for lower SNR observations. 
<P>        
        A 1D-plot of amplitudes and residual phases versus time is 
        controlled by the keyword <EM class="com">FRIB.1D_RESTIM_PLOT</EM>. 
        The residuals are coherently averaged over <EM class="com">FRIB.1D_TIM_MSEG</EM>
         accumulation periods. Averaging is not needed for high SNR observations 
        (i.e. <EM class="com">FRIB.1D_FRQ_MSEG</EM> should be set to 
        <EM class="val">1</EM>), but may be needed for lower SNR observations. 
<P>
        A 1D-plot of amplitude of the delay resolution function is 
        controlled by the keyword <EM class="com">FRIB.1D_DRF_PLOT</EM>. The delay 
        resolution is the 1D slice of the the Fourier transform of visibilities along
        the phase delay found by fringe fitting. Keyword 
        <EM class="com">FRIB.1D_DRF_SPAN</EM> defines
        the span of the plot in units of the group delay ambiguity spacings.
        Value <EM class="val">1.2</EM> is usually enough to visualize the DRF. 
        In a case of lack of phase offsets in IFs, the shape of the DRF is regular 
        with low sidelobes. The presence of phase offsets distorts the shape of 
        the DRF and raises the sidelobe which may become stronger than the main 
        maximum.
<P>
        A 2D-plot of fringe amplitude versus group delay and phase delay
        rate is controlled by the keyword <EM class="com">FRIB.2D_FRINGE_PLOT</EM>. 
        A portion of the 2D Fourier transform of visibilities is displayed. 
        Two keywords <EM class="com">FRIB.PLOT_DELAY_WINDOW_WIDTH</EM>, and 
        <EM class="com">FRIB.PLOT_RATE_WINDOW_WIDTH</EM> control
        the size of the window. Units are seconds for delay and dimensionless for
        delay rate. The size of a usable window is strongly dependent on the
        frequency sequence and duration of accumulation period. 
        <EM class="val">1.D-7</EM> for delay and <EM class="val">5.D-12</EM> delay 
        rate may be a reasonable initial choice. The best values are selected 
        by trials.
</UL>

<A NAME="mkdb"> 
<H2> Export data for astrometry/geodesy solution </H2>

   Fringe results can be transformed to the form that astrometry/geodesy
software Post-Solve can ingest. Task <EM class="task">mkdb</EM> reads 
fringe files, fringe residual file, contents of internal 
<EM class="pima">PIMA</EM> tables that are kept in <TT>SSSSS/EEE.pim</TT> 
file, and contents of visibility files, computes scan reference time (SRT), 
computes a priori path delays on the SRT, computes total group delays
and phase delay rates on SRT, sorts them, and writes them into 
database files in either binary Geo VLBI Format (GVF) or plain ascii 
(TEXT) format. In a case of dual-base observations it reads two fringe 
results and fringe residual files for both bands and matches them.
<P>

  Basic operations of this task are a) splitting the data into output
scans with their reference time; b)computation of path delay; 
c) formatting the output.
<P>

  <EM class="pima">PIMA</EM> performs baseline-dependent fringe fitting, 
and it processes observations independently. <EM class="pima">PIMA</EM> 
finds the fringe reference time (FRT) automatically as a mean weighted 
epoch among <I>used</I> accumulation periods when 
<EM class="com">FRT_OFFSET:</EM> <EM CLASS="VAL">AUTO</EM>. In general, 
the FRT is different  even if all stations had the same nominal start 
and stop time. Often VLBI experiments are scheduled in such a way that 
all stations have the same stop time but different start time. Geodetic 
schedules tends to have chaotic start and stop time when different 
antennas of the network have different start and stop epochs. 
<P>

  <EM class="pima">PIMA</EM> has several way to set the scan reference time. 
The algorithm is controlled by <EM class="com">keyword MKDB.SRT</EM>. 
If it has value <EM class="val">SRT_FRT</EM>, then <EM class="pima">PIMA</EM> 
sets the <EM class="val">SRT</EM> the same as <EM class="val">FRT</EM>. 
As a result the number of output scans, i.e. observations with the same 
epoch, tends to be the same as the number of observations, i.e. each output 
scan has only one observation. This is usually undesirable.
<P>
 
  When <EM class="com">MKDB.SRT</EM>: <EM class="val">MID_SCAN</EM>, 
<EM class="pima">PIMA</EM> consolidates time epochs in order to have as many 
as possible observations of the same scan to have the same epoch. But when
the reference epoch is moved away from the weighted mean epoch,
the uncertainty of group delay increases. <EM class="pima">PIMA</EM> has 
two keywords that controls the interval of time the scan reference time 
can deviate from the reference time for group delay uncertainty not
to grow too much: <EM class="com">MKDB.GD_MAX_ADD_ERROR</EM> and 
<EM class="com">MKDB.GD_MAX_SCL_ERROR</EM>. Keyword 
<EM class="com">MKDB.GD_MAX_ADD_ERROR</EM> specifies the tolerance 
of the absolute increase of the uncertainty in seconds. Keyword 
<EM class="com">MKDB.GD_MAX_SCL_ERROR</EM> specifies the tolerance of 
the increase of the uncertainty as a fraction of the original group delay 
uncertainty derived by <EM class="pima">PIMA</EM> task 
<EM class="task">frib</EM>. <EM class="pima">PIMA</EM> uses the smallest 
of the these two tolerances. Typical value of 
<EM class="com">MKDB.GD_MAX_ADD_ERROR</EM> is <EM class="val">5.D-12</EM>, 
typical value of  <EM class="com">MKDB.GD_MAX_SCL_ERROR</EM> is 
<EM class="val">0.2</EM>. That means that if, for example, the original path 
delay uncertainty is 40 ps, the tolerance is the smallest of 5 and 
0.2*40= 8 ps, i.e. 5 ps. <EM class="pima">PIMA</EM> determines
the SRT in such a way that the increase of the uncertainty within
the tolerance limit be minimal. If there are observations that cannot
be combined to the same SRT, <EM class="pima">PIMA</EM> splits input 
scans set by task <EM class="task">load</EM> into several output scans.
<P>

  <EM class="pima">PIMA</EM> allows a user to compute scan reference time, 
write them in file and supply the file name as the value of 
<EM class="com">MKDB.SRT</EM>. This may be useful for comparison the results 
with other fringe fitting software.
<P>

  <EM class="pima">PIMA</EM> can write the output in three different formats. 
The format is controlled by the keyword <EM class="com">MKDB.OUTPUT_TYPE</EM>. 
Value <EM class="val">TEXT</EM> instructs <EM class="pima">PIMA</EM> to 
generate a plain ascii output file with total group delays, total phase delay 
rates and many other quantities, one line per observation. Value 
<EM class="val">AMPL</EM> instructs 
<EM class="pima">PIMA</EM> to generate a plain ascii output file fringe 
amplitude, fringe phase, Tsys, gain, <I>uv</I> baseline projections and other 
parameters are written in a plain ascii table, one line per used observation. 
Results in <EM class="val">AMPL</EM> format are mainly for non-imaging flux 
density analysis. Value <EM class="val">GVF</EM> instructs 
<EM class="pima">PIMA</EM> to generates a database in binary 
<EM class="val">GVF</EM> format. VLBI analysis program Post-Solve for geodesy 
and absolute astrometry accepts GVF as input. Therefore, task 
<EM class="task">mkdb</EM> provides an interface between 
<EM class="pima">PIMA</EM> and Post-Solve.
<P>

   The database in plain ascii is not equivalent to the database in GVF 
format: the GVF database contains more parameters than the ascii database.
Therefore, the GVF database can be converted to ascii, but reverse
transformation is not feasible.
<P>

  The ascii database contains parameters for two bands. If the observations
were performed only for one band or task <EM class="task">mkdb</EM> was 
called with keyword <EM class="com">MKDB.2ND_BAND: </EM>
<EM class="val">NO</EM>, the values for the second band will be zero.
When the output for both bands is available, the band with higher
reference frequency, thereafter called <I>higher</I> precedes.
Path delay is defined as the difference of two intervals of proper time:
1) the interval of proper time measured by the clock of the first (reference)
   station between event of coming the wavefront to the reference point 
   of the first antenna and clock synchronization and
2) the interval of proper time measured by the clock of the second (remote)
   station between event of coming the wavefront to the reference point 
   of the second antenna and clock synchronization.
The antenna reference point is the point of injection of phase calibration
tone if the phase calibration was used in data analysis or the phase center
of the antenna.

The following parameters are written to the output ascii database:

<UL>
   <LI> Observation index in the database. Starts from 1.
   <LI> Observation index in PIMA. This index does not necessarily equal to 
        the observation index in the database. This index is used to associate
        a given observation in the database with an observation index in 
        <EM class="pima">PIMA</EM> internal data structures.
        </LI><P>
   <LI> Long scan name generated by <EM class="pima">PIMA</EM> in the form 
        doy_HHMMSS_iiii, where doy is the day of the year, HHMMSS is the scan 
        reference time and iiii is the scan index assigned by 
        <EM class="pima">PIMA</EM>.
        </LI><P>
   <LI> Short scan name embedded in the FITS-IDI file.
        </LI><P>
   <LI> Source name, B1950 notation. A non-standard name is allowed.
        </LI><P>
   <LI> 8-character long name of the reference (first)  station.
        </LI><P>
   <LI> 8-character long name of the remote    (second) station.
        </LI><P>
   <LI> SNR at the higher band
        </LI><P>
   <LI> SNR at the lower  band
        </LI><P>
   <LI> Scan reference time in format YYYY.MM.DD-hh:mm:ss.ffff in TAI. This time is computed
        by <EM class="task">mkdb</EM> and is rounded to an integer second.
        </LI><P>
   <LI> Scan reference time in TAI with respect to the nominal start of the first observation 
        of the experiment in seconds. NB: The first observation of the experiment is not 
        necessarily the first experiment in the database.
        </LI><P>
   <LI> Offset of the scan   reference time with respect to the nominal observation start time (sec)
        </LI><P>
   <LI> Offset of the fringe reference time with respect to the nominal observation start time at the higher band (sec)
        </LI><P>
   <LI> Offset of the fringe reference time with respect to the nominal observation start time at the lower  band (sec)
        </LI><P>
   <LI> Theoretical group delay on scan reference time computed by VTD during fringe fitting analysis (sec)
        </LI><P>
   <LI> Theoretical phase delay rate on scan reference time computed by VTD during fringe fitting analysis (dimensionless)
        </LI><P>
   <LI> A priori geocentric group delay on scan reference time for the higher band computed for the correlator (sec)
        </LI><P>
   <LI> A priori geocentric group delay on scan reference time for the lower  band computed for the correlator (sec)
        </LI><P>
   <LI> A priori geocentric phase delay on scan reference time rate for the higher band computed for the correlator (dimensionless)
        </LI><P>
   <LI> A priori geocentric phase delay on scan reference time rate for the lower  band computed for the correlator (dimensionless)
        </LI><P>
   <LI> Total group delay on scan reference time at the higher band (sec)
        </LI><P>
   <LI> Total group delay on scan reference time at the lower  band (sec)
        </LI><P>
   <LI> Total single-band delay on scan reference time at the higher band (sec)
        </LI><P>
   <LI> Total single-band delay on scan reference time at the lower  band (sec)
        </LI><P>
   <LI> Total phase delay rate  on scan reference time at the higher band (sec)
        </LI><P>
   <LI> Total phase delay rate  on scan reference time at the lower  band (sec)
        </LI><P>
   <LI> Reference frequency of the higher band. Usually this is the lowest frequency of the band. (Hz)
        </LI><P>
   <LI> Reference frequency of the lower  band. Usually this is the lowest frequency of the band. (Hz)
        </LI><P>
   <LI> Total fringe phase at the higher  band (rad)
        </LI><P>
   <LI> Total fringe phase at the lower   band (rad)
        </LI><P>
   <LI> Total geocentric phase on scan reference time at the higher band (rad)
        </LI><P>
   <LI> Total geocentric phase on scan reference time at the lower  band (rad)
        </LI><P>
   <LI> Residual geocentric phase at the higher band on fringe reference time. (rad)
        </LI><P>
   <LI> Residual geocentric phase at the lower  band on fringe reference time. (rad)
        </LI><P>
   <LI> Residual geocentric group delay at the higher band (sec)
        </LI><P>
   <LI> Residual geocentric group delay at the lower  band (sec)
        </LI><P>
   <LI> Residual geocentric phase delay rate at the higher band (dimensionless)
        </LI><P>
   <LI> Residual geocentric phase delay rate at the lower  band (dimensionless)
        </LI><P>
   <LI> Residual geocentric group delay rate on fringe reference time at the higher band (sec)
        </LI><P>
   <LI> Residual geocentric group delay rate on fringe reference time at the lower  band (sec)
        </LI><P>
   <LI> Ratio of the offset of the scan reference time with respect to nominal observation start to the nominal observation duration
        </LI><P>
   <LI> Station order in the baseline: 1 -- direct order; -1 reversed order
        </LI><P>
   <LI> Effective scan duration at the higher band in sec
        </LI><P>
   <LI> Effective scan duration at the lower  band in sec
        </LI><P>
   <LI> Elevation angle at the first  station at the scan reference time (degrees)
        </LI><P>
   <LI> Elevation angle at the second station at the scan reference time (degrees)
        </LI><P>
   <LI> Azimuth angle at the first  station at the scan reference time (degrees)
        </LI><P>
   <LI> Azimuth angle at the second station at the scan reference time (degrees)
        </LI><P>
   <LI> Uncertainty of the group delay estimate on scan reference time at the higher band (sec)
        </LI><P>
   <LI> Uncertainty of the group delay estimate on scan reference time at the lower  band (sec)
        </LI><P>
   <LI> Uncertainty of the phase delay rate estimate on scan reference time at the higher band (dimensionless)
        </LI><P>
   <LI> Uncertainty of the phase delay rate estimate on scan reference time at the lower  band (dimensionless)
        </LI><P>
   <LI> Effective ionosphere frequency for group delay for the higher band (Hz)
        </LI><P>
   <LI> Effective ionosphere frequency for group delay for the lower  band (Hz)
        </LI><P>
   <LI> Effective ionosphere frequency for phase delay for the higher band (Hz)
        </LI><P>
   <LI> Effective ionosphere frequency for phase delay for the lower  band (Hz)
        </LI><P>
</UL>

   The offset and format of each parameter is specified in the header of the ascii
database.
<P>

  Keyword <EM class="com">MKDB.OUTPUT_NAME</EM> controls the name of the 
output file. Its meaning depends on <EM class="com">MKDB.OUTPUT_TYPE</EM>. 
If the output type is <EM class="cal">TEXT</EM> or <EM class="val">AMPL</EM>, 
then the value of <EM class="com">MKDB.OUTPUT_NAME</EM> is the file name.
If the output type is <EM class="val">GVF</EM>, then the value of 
<EM class="val">MKDB.OUTPUT_NAME</EM> is the database suffix &mdash; 
a character in lower case. The database name is <TT>yyyymmdd_s</TT> where 
<TT>yyyy</TT> is the year, mm is the month number with heading zero, <TT>dd</TT>
is the day of the month with heading zero and is the suffix specified by 
<EM class="com">MKDB.OUTPUT_NAME</EM>. Suffixes <TT>a-e</TT> are
reserved to imported databases converted from MARK3-DBH or vgosdb 
formats to gvf. Suffixes <TT>x-z</TT> are resolved for tests.
<P>

  In order to generate the output in GVF format, <EM class="pima">PIMA</EM> 
requires some additional information that it cannot find in FITS-IDI files
with visibilities. This information is supplied in an the experiment
description file. The name of that file is the value of keyword
<EM class="com">MKDB.DESC_FILE</EM>. If the value of 
<EM class="com">MKDB.DESC_FILE</EM> is <EM class="val">NO</EM>, then no 
information that is supposed to be defined in the experiment
description is exported to the output database.
<P>

  <EM class="pima">PIMA</EM> can put in the output database two frequency 
bands in the dual-band experiment. The fringe fitting procedure runs twice 
for a dual-band experiment. The second band can either occupy a range
of IFs or a frequency group. <EM class="pima">PIMA</EM> requires to have 
two control files for the lower and upper bands. Task <EM class="task">mkdb</EM> 
should use the control file with the upper band. The file for the upper band of
dual-band data should have a reference to the control file file
for the lower band. The name of the control file for the lower band
is specified in the keyword <EM CLASS="com">MKDB.2ND_BAND</EM>. 
<P>

   Post-Solve has two slots for group delays, phase delay rates and
other quantities: the 1st and the 2nd. Post-Solve assumes the first 
slot is the the upper frequency and the second one is for the lower
frequency but it does not check.
<P>

  Keyword <EM CLASS="com">MKDB.2ND_BAND</EM> should have value 
<EM class="val">NO</EM> for single band experiment and for the control 
file for fringe fitting the lower band. It should have the name of the 
control file for the lower band inside the control file for  the upper 
band of a dual-band experiment.
<P>

  <EM class="pima">PIMA</EM> needs to know where to write the output database 
in GVF format. Keyword <EM CLASS="com">MKDB.VCAT_CONFIG</EM> specifies 
the configuration file for VLBI database catalogue. That configuration file 
defines two directories: directory for ascii envelope wrappers 
(keyword <EM CLASS="com">GVF_ENV_DIR</EM>) and directory for binary files 
(keyword <EM CLASS="com">GVF_DB_DIR</EM>). The same configuration
files is supposed to be used by Post-Solve. Post-Solve assumes that
configuration file has name $SAVE_DIR/vcat.conf . Therefore, in order
Post-Solve to find the database crested by <EM class="pima">PIMA</EM>, 
the control file should specify $SAVE_DIR/vcat.conf with environment 
variable SAVE_DIR expanded.
<P>

  Database file in GVF format can be read with GVH library. The GVH
package has routine gvf_transform that can transform from binary
representation of the database to the ascii and back to binary form.
The ascii representation of a database is human readable. Moreover,
Post-Solve can work with both ascii and binary representation, binary
representation being more than one order of magnitude faster. 
Transformation to an ascii representation can be useful for simple
editing  such as replacement of source name or station name.
<P>

  Post-Solve classifies observations as good, bad, but recoverable,
and bad unrecoverable. The latter category is not visible and Post-Solve
does not allow to recover them. The common reasons for that: 1) SNR less
than the limit specified in the keyword <EM class="com">FRIB.SNR_DETECTION</EM>
of the <EM class="pima">PIMA</EM> control file; 2) lack of phase calibration 
for a given observation when <EM class="com">pcal</EM> is anything else than 
<EM class="val">NO</EM>; failure in fringe fitting, f.e. because there are 
less than 3 valid accumulation periods. Since <EM class="pima">PIMA</EM> 
does not determine whether an observation is really detected or not, if 
<EM class="com">FRIB.SNR_DETECTION</EM> is too high, there is a chance that 
Post-Solve will miss good observations. For this reason, it is recommended 
to set a rather low <EM class="com">FRIB.SNR_DETECTION</EM> parameters, f.e. 
<EM class="val">5.0</EM>, and then set the SNR limit in Post-Solve but hitting 
<B>J</B>. Post-Solve sets the SNR limit temporarily. The observations below 
the limit are considered unrecoverable until the limit is changed. If the SNR 
limit is lowered, but not below the limit used by <EM class="pima">PIMA</EM>, 
the observation from bad and unrecoverable becomes bad and recoverable. 
Reducing the SNR limit in Post-Solve below the limit used by 
<EM class="pima">PIMA</EM> does not have effect.
<P>

  A suggested strategy is to set a <EM class="com">low FRIB.SNR_DETECTION</EM>, 
<EM class="val">5.0</EM>, and after loading the database into Post-Solve set 
higher SNR limit in Post-Solve, <EM class="val">5.8&ndash;6.0</EM>. After 
cleaning the database for outliers with SNR limit 
<EM class="val">5.8&ndash;6.0</EM> the limit is lowered to the value used by 
<EM class="pima">PIMA</EM>. Such a strategy avoids the problem of 
contamination the dataset with too many outliers which may cause difficulties 
in initial analysis, since too many outliers, say more than 10% may 
significantly skew residuals.

<A NAME="expo"> 
<H2> Split and export data for imaging </H2>

   <EM class="pima">PIMA</EM> has a capability to format its results in the 
form that is suitable for both absolute astrometry/geodesy or imaging. In the 
latter case <EM class="pima">PIMA</EM> coherently averages the visibilities 
over time and frequency and applies all necessary calibrations and 
re-normalizations. 
<P>

  If a given observation, given IF does not system temperature or antenna
gain, or have Tsys out of range [10, 10000]K or have zero gain, the
visibility for such an observations, such an IF is discarded. Therefore,
calibration for system temperature and antenna gain must be performed before
running task <EM class="task">splt</EM>. In contrast, the data without 
amplitude calibration are still usable for absolute astrometry/geodesy. 
Flagging data for the time intervals when the antennas were off-sources 
is essential for deriving a good-quality image. Flagging can also be 
performed before <EM class="task">mkdb</EM>, although usually it has 
only a marginal effect.

<A NAME="gain"> 
<H2> Import gain curves </H2>

  As of 2016, only the NRAO generates visibility data that are
fully compliant with FITS-IDI specifications and contain gain curves.
Data generated by other correlators do not have this information, and
therefore, the gain curves should be imported. Import gain curves 
is beneficial for processing VLBA data, since the gain curves embedded
in the database may not be the best one. 
<P>

  <EM class="pima">PIMA</EM> task <EM class="task">prga</EM> (PRint GAin) 
prints gain for each station, each IF. It is recommended to inspect these 
values.
<P>

  <EM class="pima">PIMA</EM> supports two formats of gain information: 
VLBA gain and EVN gain files. The VLBA gain format allows to specify 
different gain for time ranges, and therefore, this format is preferable.
<P>

  Gain file specifies gain at the reference elevation, the so-called 
Degrees Per Flux Unit (DPFU) factor in Jy/K for R and L polarizations for 
a certain frequency range and a set of coefficients that specify the 
polynomial that describes the dependence of gain with elevation &mdash; that 
is why it is called "gain curve". If the elevation dependence is not known, 
than the polynomial has only one coefficient for degree 0: 1.0
<P>

  <EM class="pima">PIMA</EM> task <EM class="task">gean</EM> allows to import
gain curves. It requires either qualifier vlba_gain or evn_gain. The value of
the qualifier is the file name with gains. When the firsts qualifier is 
<EM class="val">vlba_gain</EM> <EM class="pima">PIMA</EM> requires the second 
qualifier <EM class="val">gain_band</EM> that specifies the band. Supported 
bands are class="val">90cm</EM>, class="val">50cm</EM>, class="val">21cm</EM>, 
class="val">18cm</EM>, class="val">13cm</EM>, class="val">13cmsx</EM>, 
class="val">6cm</EM>, class="val">7ghz</EM>, class="val">4cm</EM>, 
class="val">4cmsx</EM>, class="val">2cm</EM>, class="val">1cm</EM>, 
class="val">24ghz</EM>, class="val">7mm</EM>, class="val">3mm</EM>. 
NB: <EM class="pima">PIMA</EM> does not check whether the band is supported.
<P>

  <EM class="pima">PIMA</EM> wrapper <EM class="wrap">pf.py</EM> does this 
task as well. It assumes to find files vlba.gains and ivs.gains in directory 
specified by configuration parameter --stable-share. 
<EM class="wrap">pf.py</EM> wrapper tries both gain files. 
<P>

  Task <EM class="task">gean</EM> does not report an error, if it does not 
find a gain for the specific station, specific frequency range, specific time 
interval. If it does not find gain, the gain is set to zero. If the gain is 
zero for a given station, given IF, <EM class="pima">PIMA</EM> task 
<EM class="task">splt</EM> will not export visibilities for a given station. 
It is recommended to inspect gain values by running <EM class="pima">PIMA</EM> 
task <EM class="task">prga</EM> after importing gains in order to be sure the 
are correct. Wrapper <EM class="wrap">pf.py</EM> runs 
<EM class="task">prga</EM> automatically at the end. The results an be found 
in the log file of task <EM class="task">gain</EM>.


<A NAME="onof"> 
<H2> Flagging visibilities with low amplitude at the beginning or end 
of a scan. </H2>

  Data acquisition system often record before and/or after the actual 
scan time. The field system  is supposed to record time stamp of nominal
start and nominal stop time and the correlator is supposed to flag accumulation
periods that were recorded when the antennas were off-source. However, it may
happen that visibility data for a given time have intervals when the antenna
were off-source. Usually, this happens at the beginning of the scan. This
may happen because the fields system software incorrectly determine on/off
time, or did not propagate it to the correlator, or the antenna was off while
the fields system software reported the antenna was on. Propagation such "data" 
poses a serious problem for imaging. Such visibilities should be flagged during 
imaging stage. If left unflagged they distort an image. 
<EM class="pima">PIMA</EM> has task <EM class="task">onof</EM> that analyzes 
the data, determines accumulation periods with the fringe amplitude at the 
beginning and/or the end of a scan with fringe amplitude below the threshold 
and flag them out. This task should run before <EM class="task">splt</EM>.
<P>

  <EM class="pima">PIMA</EM> supports two mechanisms for flagging visibility. 
When <EM class="pima">PIMA</EM> loads the data, it
checks all visibilities for inconsistencies, such as lack of autocorrelation,
wrong source indices, duplicates, etc. It puts indices of damaged visibilities
in a separate file and bars them from loading. These visibilities are 
considered unrecoverable. <EM class="pima">PIMA</EM> supports keyword 
<EM class="com">TIME_FLAG_FILE</EM> that defines a so-called time epoch flag 
file. The file flag file consists of records in plain ascii that defines 
the visibility to be flagged. A record consists of four words separated by 
one or more blanks. The first word is the observation index, the second word 
is the index of the accumulation period within that observation, and the third
word is a flag. The flag is multiplied by the visibility. Flag 0 means the 
visibility will not be used for further processing. Lines that start with 
# are considered as comments and discarded by <EM class="pima">PIMA</EM>.
<P>

  Task <EM class="task">onof</EM> uses this mechanism to flag out bad 
accumulation periods. It determines accumulation periods with low amplitude 
and write their indices and observation indices into the time epoch file. 
Other tasks, such as  <EM class="task">frib</EM>, <EM class="task">splt</EM>
read this file and flag out visibilities that have corresponding indices.
<P>

  Task <EM class="task">onof</EM> does not require qualifiers. Its behavior
is determined by a number of keywords of the control file. If Keyword 
<EM class="com">ONOF.GEN_FLAGS_MODE</EM> is <EM class="val">CREATE</EM>, 
<EM class="pima">PIMA</EM> will ignore the previous contents of the flag 
file and overwrite it. If <EM class="com">ONOF.GEN_FLAGS_MODE</EM> is 
<EM class="val">UPDATE</EM>, then <EM class="pima">PIMA</EM> will honor
input of the flag file specified by the keyword 
<EM class="com">TIME_FLAG_FILE</EM> and update it. In this mode 
<EM class="pima">PIMA</EM> will never reduce the number of flagged 
visibilities, but it can only increase them.
<P>

  In order to determine accumulation periods at the beginning or the end
of the scan that have to flags, <EM class="pima">PIMA</EM> needs to get 
a hint which interval to consider as "good". Two keywords, 
<EM class="com">ONOF.KERNEL_START_SHARE</EM> and 
<EM class="com">ONOF.KERNEL_END_SHARE</EM> determine the so-called kernel 
interval. The value of these keywords are the offsets or the kernel start 
and stop time as a share of the total nominal scan length. The share runs 
from 0 to 1. instance, <EM class="com">ONOF.KERNEL_START_SHARE</EM>:  
<EM class="val">0.25</EM>, <EM class="com">ONOF.KERNEL_END_SHARE</EM>: 
<EM class="val">0.80</EM> specifies the kernel interval that starts at 
0.25*scan_length and ends at 0.80*scan_length. However, the length of the 
kernel interval is limited by the value of 
<EM class="com">ONOF.COHERENT_INTERVAL</EM> (in seconds). If parameters
<EM class="com">ONOF.KERNEL_START_SHARE</EM> and 
<EM class="com">ONOF.KERNEL_END_SHARE</EM> specify the interval longer
than <EM class="com">ONOF.COHERENT_INTERVAL</EM>, then 
<EM class="com">ONOF.KERNEL_END_SHARE</EM> is reduced in such a way that 
the kernel interval will be close, but not exceeding 
<EM class="com">ONOF.COHERENT_INTERVAL</EM>.
<P>

   <EM class="pima">PIMA</EM> first computes coherently averaged complex 
visibilities over the kernel interval and then tries visibilities coherently 
averaged over frequency over and accumulation periods backwards from the start 
of the kernel interval and forward from the end of the kernel interval. 
<EM class="pima">PIMA</EM> computes the frequency averaged visibility 
amplitudes, computes the ratio of the visibility amplitude over the trial 
accumulation to the amplitude over the kernel interval and tries two 
criteria: a) if the ratio is less than (1-k*&sigma;<sub>a</sub>), where 
<TT>k</TT> is the value of the keyword 
<EM class="com">ONOF.NSIG_THRESHOLD</EM> and &sigma;<sub>a</sub>, then the 
accumulation periods is marked as a candidate for exclusion; b) if the ratio 
is less than <EM class="com">ONOF.AMPL_THRESHOLD</EM>, then the accumulation 
periods is marked as a candidate for exclusion. If 
<EM class="com">ONOF.AMPL_THRESHOLD</EM> is zero then the first criterion is 
disabled. If <EM class="com">ONOF.AMPL_THRESHOLD</EM> is zero, then the second 
criterion is disabled. If <EM class="com">ONOF.NSIG_THRESHOLD</EM> &gt; 0.0, 
the second criteria is used only if the ratio of the amplitude in the kernel 
interval to the uncertainty amplitude at a given accumulation period is less 
than <EM class="com">ONOF.NSIG_THRESHOLD</EM>.
<P>

  If <EM class="pima">PIMA</EM> finds k consecutive candidates, where 
<TT>k</TT> is the value of keyword <EM class="com">ONOF.MIN_LOW_AP</EM>, 
then it flags them and all consecutive visibilities at the beginning or 
the end of the scan. 
<P>

    Criterion <EM class="com">ONOF.AMPL_THRESHOLD</EM> is suitable for 
observations with high SNR and long accumulation periods. Visibility 
amplitude computed over one accumulation period has a large scatter and 
the fluctuations caused by noise may be mistakenly considered as the source 
being off source.
<P>

    Criterion <EM class="com">ONOF.NSIG_THRESHOLD</EM> is suitable for both 
low SNR and high SNR observations. Value <EM class="val">3</EM> was found 
satisfactory for most of cases. Task <EM class="task">onof</EM> is not able 
to find time interval when antennas were off-source for observations with 
low SNR, say less than 10, because amplitude fluctuations due to random 
noise become too large to be distinguished from antennas being off-source.
  

<A NAME="splt"> 
<H2> Running task splt for splitting and exporting data for imaging </H3>

  Using results of fringe fitting, <EM class="pima">PIMA</EM> performs 
coherent averaging over time and frequency after rotation phases according 
to group delays and phase delay rates, applies calibration for system 
temperature, gain curves, bandpass re-normalization, combines all visibilities 
of a given source and writes averaged visibilities and their weights into
output binary files in FITS format that are suitable for imaging with
AIPS or DIFMAP.
<P>

  Task <EM class="task">splt</EM> processes the data on source basis. A user 
can specify the source name that will be processed or to request to process all
the sources in a cycle. Keyword <EM class="com">SPLT.SOU_NAME</EM> controls 
this behavior. Its value can be either B-name, or J-name or ALL, which means 
to process all the sources.
<P>  

  Keyword <EM class="com">SPLT.FRQ_MSEG</EM> specifies the number of spectral
channels to be coherently averaged out. A usual choice for processing legacy 
data is to specify the number of spectral channels in an individual IF. In 
that cases all spectral channels will be averaged out. 
<EM class="pima">PIMA</EM> does not average spectral channels across IF 
boundaries. That means that the maximum value of 
<EM class="com">SPLT.FRQ_MSEG</EM> is limited to the number of channels in 
an IF. Starting from 2014, observations at 512 MHz band became more and more
common. Averaging across 512 MHz band may result to image smearing.
Therefore, it may appear beneficial to decrease the number of spectral
channels that will be averaged. Task <EM class="task">splt</EM> averages 
<EM class="com">SPLT.FRQ_MSEG</EM> spectral channels in one output IF. 
If <EM class="com">SPLT.FRQ_MSEG</EM> is less than the number spectral channels 
in one IF, then the output dataset will have more output IFs than the input 
dataset.
<P>

   Keyword <EM class="com">SPLT.TIM_MSEG</EM> specifies the number of 
accumulation periods to be coherently averaged out. The interval of time that 
with <EM class="com">SPLT.TIM_MSEG</EM> accumulation periods is called segment. 
A usual choice is to select segment duration 10&ndash;20 seconds. DIFMAP allows
to averaged data further increasing segment length (DIFMAP task uvaver), but 
after the data have been averaged, there is no way to undo averaging. In a case 
when a very large map will be made, <EM class="com">SPLT.TIM_MSEG</EM> may be 
reduced in order to avoid image smearing.
<P>

   Keyword <EM class="com">SPLT.SNR_MIN</EM> specifies the SNR threshold.
Observations with the SNR over all frerquencies and over total scan duration
less than that threshold are excluded for processing and are not writtebn 
in the output file.
<P>
 
  One output visibility is a result of coherent averaging over
<EM class="com">SPLT.FRQ_MSEG</EM>*<EM class="com">SPLT.TIM_MSEG</EM> input 
visibilities. It should be noted that if <EM class="com">SPLT.FRQ_MSEG</EM> 
is not an integer divisor of the number of spectral channels and 
<EM class="com">SPLT.TIM_MSEG</EM> is not an integer divisor of the total
number of accumulation periods of an observation, the number of used input 
visibilities can be less at the end of the observation or at the upper part 
of the spectrum can be less.
<P>

  Phases of input visibilities are rotated before averaging according
to phase delay rate and group delays that are found during fringe 
fitting. <EM class="pima">PIMA</EM> reads results of fringe fitting from 
the file specified by the keyword <EM class="com">FRINGE_FILE</EM>. 
<P>

  Since <EM class="pima">PIMA</EM>  performs fringe fitting for each 
observation independently, in general, fringe reference time is different. 
As a result, the misclosure of the <I>raw</I> phases from the contribution 
of group delay and phase delay rates is not zero. If 
<EM class="com">SPLT.STA_BASED</EM>: <EM class="val">YES</EM> or 
<EM class="val">ALL</EM>, then <EM class="pima">PIMA</EM> performs 
a procedure that converts baseline-dependent group delays and phase delay 
rates to station-based that automatically have zero misclosure and therefore,
applying phase rotation from the results of fringe fitting does not change 
misclosure in original visibilities. <EM class="pima">PIMA</EM> performs 
this conversion at each scan. It may happen that observations of a given 
scan have to be split into several subarrays. A subarray is a set of 
observations that has common baselines 
with <I>every</I> station within a subarray. For example a station array 
<TT>ABCDRFG</TT> may have to be split into two subarrays <TT>ABCD</TT>  and
EFG if there are no <I>usable</I> observations at baselines <TT>AE,AF,AG</TT>,
<TT> BE,BF,BG,CE,CF,CG,DE,DF,DG</TT> . If in this example, there are no 
usable data at baseline <TT>FG</TT>, there will be three subarrays: 
<TT>ABCF</TT>, <TT>EF</TT>, <TT>EG</TT>. <EM class="pima">PIMA</EM> splits 
the data into subarrays for processing each scan. If a subarray for a given
station was already used in the previous scans, <EM class="pima">PIMA</EM> 
assigns the observations to that subarray. In a case if a new subarray has 
all the stations that were in one of the previous subarrays, 
<EM class="pima">PIMA</EM> assigns observations to that subarray. In a case 
is a new subarray has all the stations that were in one of the previous 
arrays, plus one or more new station, <EM class="pima">PIMA</EM> extends 
that subarray, and assigns the observations to that subarray.
<P>

  In a case if all scans were scheduled at all antennas and fringes were 
detected at all observations and no observations were excluded, there will 
be only one subarray. If one of these conditions is violated, 
<EM class="pima">PIMA</EM> may end up with many subarrays. Since splitting 
data in many subarrays reduces the number of phase and amplitude misclosures,
in general it is undesirable to have many subarrays. 
<EM class="pima">PIMA</EM> supports a procedure subarray consolidation 
controlled by the keyword <EM class="com">SPLT.SUBARRY_CONSOLIDATION</EM>. 
Value <EM class="val">NO</EM> means to disable subarray consolidation. Value 
<EM class="val">MIN</EM> instructs <EM class="pima">PIMA</EM> to preform 
minimal subarray consolidation: if all stations of subarray <TT>A</TT> are 
present in the subarray <TT>B</TT>, then the subarray <TT>B</TT> is 
consolidated with subarray <TT>A</TT>. Value <EM class="val">MAX</EM> 
instructs to preform maximum subarray consolidation: if a subarray has 
at least one common station with subarray <TT>B</TT>, both subarrays are 
consolidated.  
<P>

  In order to compute station-dependent group delay, phase delay, and
group delay correctly, baseline-dependent group delay, phase delay, and
group delay should be correct. Fringe fitting provides a wrong result
for a non-detection, or an observation affected by RFI. Group delays
of non-detections have a uniform distribution over the fringe search
window, which is several orders of magnitude larger than the scatter
of group delays for normal observations. Therefore, a care should taken
in order to block using bad group delays by task 
<EM class="task">splt</EM>. It is recommended to process the data with
VTD/Post-Solve in order to identify outliers and exclude them as input 
to the procedure for computing station-based group delay, phase delay
and group delay rate using keyword <EM CLASS="com">EXCLUDE_OBS_FILE</EM>.
If <EM class="com">SPLT.STA_BASED</EM>: <EM class="val">YES</EM> is used,
the observations excluded for computing station-based quantities will
remain excluded from  being further processed and written in the the
output file. However, in general, this approach is too restrictive.
When <EM class="com">SPLT.STA_BASED</EM>: <EM class="val">ALL</EM> is
specified, the filters specified by kewords 
<EM class="com">FRIB.SNR_DETECTION</EM>, 
<EM CLASS="com">EXCLUDE_OBS_FILE</EM>,
<EM CLASS="com">INCLUDE_OBS_FILE</EM>, and <EM CLASS="com">OBS</EM>
is applied only to the input data of the procedure for computing 
station-based quantities. All observations between the stations for 
which station-dependent group delays, phase delay, and group delays 
are computed are used for further processing, regardless whether they
passed the input filter or not. Though if there were no observations
at baselines at certain stations, there will be no station-based 
quatnties for these stations, and therfore, no for the observations 
with these stations will be used for generating the output.
Value <EM class="val">ALL</EM> is recommended.
<P>
   
   Alternatively, when <EM class="com">SPLT.STA_BASED</EM>: 
<EM class="val">NO</EM>, <EM class="pima">PIMA</EM> does not convert 
baseline-dependent quantities to station-based. Important: phase misclosure 
is distorted when this option is used. This option is useful when the data 
are to be processed on a baseline basis. 
<P>

   Keyword <EM class="com">SPLT.SNR_MIN</EM> specifies the SNR threshold
for the output. Observations with the SNR over all frequencies and over 
total scan duration less than that threshold are excluded for processing 
and are not written in the output file. This criteria is used after 
the averaged visibilities are computed. If 
<EM class="com">SPLT.STA_BASED</EM>: <EM class="val">YES</EM> or
<EM class="com">SPLT.STA_BASED</EM>: <EM class="val">NO</EM> was used,
observations with SNR less than <EM class="com">FRIB.SNR_DETECTION</EM>
will remained excluded even if their SNR is equal or greater than
<EM class="com">SPLT.SNR_MIN</EM>. However, when 
<EM class="com">SPLT.STA_BASED</EM>: <EM class="val">ALL</EM> is 
specified, observations with SNR less than 
<EM class="com">FRIB.SNR_DETECTION</EM> may become valid. For instance,
if stations  B and C have low sensitivity, but station A has high
sensitivity, visibilities at baseline BC can be determined using phase
delay rate and group delay at baselines AB and AC. The SNR of visibilities
at baseline BC may be very low. Keyword <EM class="com">SPLT.SNR_MIN</EM> 
allows to filter out such visibilities with low SNR computed on the basis
fringe fitting results from visibility analysis at other baselines.
<P>

   There are several options to generate the output in a case of
dual-polarization data. Keyword <EM class="com">SPLT.POLAR</EM> specifies 
which polarizations to put in the output: <EM class="val">ALL</EM> for all 
polarizations that present in the data, <EM class="val">PAR</EM> only for 
<EM class="val">RR</EM> or <EM class="val">LL</EM> polarizations. Other 
supported values: <EM class="val">I</EM>, <EM class="val">RR</EM>, 
<EM class="val">RL</EM>, <EM class="val">LR</EM>, and <EM class="val">LL</EM>.
<P>

   <EM class="pima">PIMA</EM> computes averaged visibilities and their weights. 
The algorithm for weights computation is controlled by keyword 
<EM class="com">SPLT.WEIGHT_TYPE</EM>. According to FITS specifications, 
weight is defined as reciprocal to the fringe amplitude variance. Value 
<EM class="val">ONE</EM> forces <EM class="pima">PIMA</EM> to set all weights 
to 1. Value <EM class="val">OBS_SNR</EM> instructs <EM class="pima">PIMA</EM> 
to compute weights on the basis of signal to noise ratio SNR. The segment 
weight is Ampl/SNR**2, where SNR is the signal to noise ratio over 
visibilities of a given segment. The segment SNR  computed from the SNR over 
all visibilities used in fringe fitting and scaled by square root of the the 
ratio of visibilities in the segment to the total number is used visibilities
in the observation. When <EM class="com">SPLT.WEIGHT_TYPE</EM> is 
<EM class="val">OBS_RMS</EM>, <EM class="pima">PIMA</EM> computes variance of 
the fringe amplitude over the observation and assigns weights for all segments 
reciprocal to this estimate of variance. When 
<EM class="com">SPLT.WEIGHT_TYPE</EM> is <EM class="val">SEG_RMS</EM>, 
<EM class="pima">PIMA</EM> computes variance of fringe amplitude over 
visibilities of a given segment and assigns weights reciprocal to this 
variance.
<P>

   Method <EM class="val">SEG_RMS</EM> is the preferable, since it accounts for 
temporal variation of the variance. However, it requires a sufficient number of 
segments for computing meaningful variance. When 
<EM class="com">SPLT.WEIGHT_TYPE</EM> is <EM CLASS="VAL">AUTO</EM>, 
<EM class="pima">PIMA</EM> uses different ways to use the weight depending on 
the number of accumulation periods in a given segments. If the number of 
accumulation periods per segment specified in the keyword 
<EM class="com">SPLT.TIM_MSEG</EM> is equal or greater than the threshold 
(currently 8), the variance is computed over visibilities of a given segment. 
Otherwise, the variance will be computed over all visibilities of the 
observation (equivalent to <EM class="val">OBS_RMS</EM>). 
<EM class="com">SPLT.WEIGHT_TYPE</EM>: <EM class="val">AUTO</EM> is recommended 
for a general case. 
<P>

  When computing calibrated amplitude <EM class="pima">PIMA</EM> applies two 
renormalizations unless a user disables it. When 
<EM class="com">SPLT.AUTOCORR_NRML_METHOD</EM>: <EM class="val">AVERAGED</EM>, 
<EM class="pima">PIMA</EM> normalizes system temperature for masking 
autocorrelation. The system temperature is measured by integrating the total 
power over entire IF. When a portion of the bandwidth where Tsys was computed 
is masked out, the total power is changed. In general, the spectrum of noise 
is not constant over the band, it is proportional to the autocorrelation. 
<EM class="pima">PIMA</EM> normalizes autocorrelation to have the average equal 
to 1 over the nominal IF width. When 
<EM class="com">SPLT.AUTOCORR_NRML_METHOD</EM>: <EM class="val">AVERAGED</EM>, 
<EM class="pima">PIMA</EM> computes the mean autocorrelation over the used 
portion of the bandwidth within each IF, which in general is not 1. Then fringe 
amplitude is divided by the mean autocorrelation. 
<EM class="com">SPLT.AUTOCORR_NRML_METHOD:</EM> <EM class="val">NO</EM> 
disables applying this renormalization. It is recommended to use 
<EM class="com">SPLT.AUTOCORR_NRML_METHOD:</EM> <EM class="val">AVERAGED</EM>.
<P>

   When <EM class="com">SPLT.BPASS_NRML_METHOD</EM>: 
<EM class="val">WEIGHTED</EM>, <EM class="pima">PIMA</EM> divides the fringe 
amplitude by the square root of the product of the square root
of bandpass renormalization factor. The representative bandwidth of the 
intermediate frequency used for re-normalization is specified by the
keyword <EM class="com">SPLT.BPASS_NRML_RANGE</EM>. The value of this keyword 
is two numbers from 0 to 1 separated by the colon. These number specify the 
lower and the high part of the representative bandwidth as a share of the 
total bandwidth.  Example: <EM class="com">SPLT.BPASS_NRML_RANGE:</EM> 
<EM class="val">0.25:0.80</EM>. They define the representative bandwidth as 
<TT>[F_low + Bl*Fw, F_low*Bh*fw]</TT>. <EM class="pima">PIMA</EM> computes 
renormalization factor <TT>R = (sum B<sub>r</sub>/N<sub>r</sub> ) / 
Sum B<sub>t</sub>/N<sub>t</sub>, </TT> where B<sub>r</sub> &mdash; 
bandpass in the bandwidth is <TT>[F_low + Bl*Fw, F_low*Bh*fw],</TT> 
N<sub>r</sub> &mdash; the number of points in that bandwidth; B<sub>t</sub> 
bandpass in the total bandwidth, N<sub>t</sub> the total number of points 
in the entire IF. Factor R is multiplied by every point of the bandpass and
makes its normalized over the representative bandwidth 
<TT>[F_low + Bl*Fw, F_low*Bh*fw]</TT>. Usually <TT>R &gt; 1.0 </TT>
For example, if the IF bandwidth is 16 MHz and 
<EM class="com">SPLT.BPASS_NRML_RANGE:</EM> <EM class="val">0.25:0.80</EM>,
then the representative portion of the bandwidth used for renormalization 
starts at 0.25*16=4.0 MHz and ends at 0.8p*16=12.8 MHz. Thus, the portion
<TT>[4.0, 12.8] MHz</TT> of the total bandwidth <TT>[0, 16] MHz</TT> is
considered representative and the bandpass is normalized to be 1 over the
representative portion of the bandwidth. The share of the representative 
bandwidth depend on quality of hardware. <EM class="val">0.25:0.80</EM>
is a good choice for most of the cases.

<P>
   In addition to generating the output averaged visibilities in FITS-IDI
format, <EM class="pima">PIMA</EM>  task <EM class="task">splt</EM> 
will generate total visibilities averaged over entire can when 
<EM class="com">SPLT.TOTAL_UV:</EM> <EM class="val">YES</EM> is specified.
<B>NB:</B> unlike to averaged visibilities written in the FITS-IDI format,
the total visibilities are refereed to the band reference frequency.
Name of a file with total visibilities obeys the following convention:
<TT>JJJJJJJJJJ_B_uvt.txt</TT>, where <TT>JJJJJJJJJJ</TT> is the 10-character
long J2000 source name and B is the band defined in the keyword 
<EM class="com">BAND</EM>. Total visibilities are written in the plain
ascii format. See document Total_visibilities_format.txt for format description.

<A NAME="gaco"> 
<H2> Compute gain correction </H2>

   It is rather common from some stations to have some IFs with gain
to be wrong by a certain factor. This may be due to unaccounted change
in gain curve, or due to systematic error in Tsys. During imaging process
gain can be adjusted using amplitude closure. This procedure is called
amplitude self-calibration. However, a source should be relatively bright
and UV coverage should be rather dense for amplitude self-calibration
to produce good results. If the gain is off by a factor that is constant 
over entire experiment, the gain correction determined from imaging one
source can be used as a priori for imaging other sources. This is just
that <EM class="pima">PIMA</EM>  task <EM class="task">gaco</EM> 
(GAin COrrection) does.
<P>

  <EM class="pima">PIMA</EM> supports keyword 
<EM class="com">SPLT.GAIN_CORR_FILE</EM> that specifies so-called gain
correction file. This file in plain ascii format defines factors for each 
station and each IF by which fringe is multiplied when task 
<EM class="task">splt</EM> runs.
<P>
 
  These factors can be assigned manually or automatically. Task 
<EM class="task">gaco</EM> can run in two modes: manual and automatic. 
In manual mode <EM class="pima">PIMA</EM> expects a qualifier init with 
the value of the a priori factor. Value <EM class="val">1.0</EM> or 
<EM class="val">0.0</EM> are usual choices. Task 
<EM class="task">gaco</EM> with qualifier <EM class="val">init</EM> 
sets all gains to the initial value. Gain correction 1.0 means 
no correction. Gain correction 0.0 means all IFs all stations should 
be deselected.
<P>

  Task <EM class="task">gaco</EM> writes the gain correction file. If task 
<EM class="task">gaco</EM> was invoked in <EM class="val">init</EM> mode, 
the gain correction should be edited in order to be useful. Example: station 
KP-VLBA had fringe amplitude a factor of 8&ndash;10 lower in IFs 3 and 4, 
and a user would like to get rid of them for imaging purposes. Than 
<EM class="pima">PIMA</EM> task <EM class="task">gaco</EM> with qualifier 
<EM class="val">init</EM> and value <EM class="val">1.0</EM> is called.
After that the user edits the gain correction file that the task 
created ad changes gain correction for KP-VLBA IFs 3 and 4 from 1.0 to 0.0.
<P>

  In order to to compute gain corrections in the automatic mode, several
images should be made first and self-calibrated visibilities be saved.
Then <EM class="pima">PIMA</EM> analyzes the ratio of original amplitudes 
before amplitude self-calibration and after amplitude self-calibration and 
determines their ratios for each station and each IF using least squares. 
These gain corrections are equivalent to the factors should by task CORPLT 
of DIFMAP package. In order to do it, <EM class="pima">PIMA</EM> should find 
visibilities before and after imaging. <EM class="pima">PIMA</EM> supports 
convention that a file with visibilities before imaging have name 
<TT>JJJJJJJJJJ_B_uva.fits</TT>, where <TT>JJJJJJJJJJ</TT> is the 10-character
long J2000 source name and B is the band defined in the keyword 
<EM class="com">BAND</EM>. <EM class="pima">PIMA</EM> task 
<EM class="task">splt</EM> created files with averaged visibilities in this 
format. <EM class="pima">PIMA</EM> expects files with self-calibrated 
visibilities after imaging to have names in the form of 
<TT>JJJJJJJJJJ_B_uvs.fits</TT>.
<P>

  When used in the automatic mode, <EM class="pima">PIMA</EM> task 
<EM class="task">gaco</EM> expects two qualifiers, <EM class="val">sou</EM> and 
<EM class="val">dir</EM>, the first is mandatory and the second is optional. 
The value of the first qualifier is a comma-separated source list. The value of 
the second optional qualifier specifies the directory where files with original
and self-calibrated visibilities can be found (they should be in the same 
directory). If the second qualifier is omitted, <EM class="pima">PIMA</EM> will 
search for visibilities in the same directory where task 
<EM class="task">splt</EM> put them: <TT>SSSSS/EEE_uvs</TT>, where 
<TT>SSSSS</TT> is the <EM class="pima">PIMA</EM> scratch directory specified 
by the keyword <EM class="com">EXPER_DIR</EM> and <TT>EEE</TT> is the experiment 
name specified by the keyword <EM class="com">SESS_CODE</EM>.
<P>

  <EM class="pima">PIMA</EM> task <EM class="task">gaco</EM> used in the 
automatic mode computes the gain correction file. If a given station observed 
no sources from the list, the gain correction for that station is set to 1.0. 
A user may edit the gain correction file, for instance setting zeros for IFs 
for certain station(s). Setting the gain correction to zero will effectively 
flag out these IFs for <I>imaging purposes</I>, while these IFs are still 
available for other tasks, for example, fringe fitting.
<P>

  <EM class="pima">PIMA</EM> task <EM class="task">splt</EM> uses gain file, 
unless <EM class="com">SPLT.GAIN_CORR_FILE</EM>: <EM class="val">NO</EM>. 
It multiplies the calibrated visibility by the product of gain corrections 
of both stations of a baseline. It writes the used gain corrections into 
output FITS file in two places: 1) as an ascii  table in the HISTORY records 
of the main table, 2) as a new table in GACO. It is possible to run task 
<EM class="task">taco</EM> the second time. <EM class="pima">PIMA</EM> 
searches for gain correction in the FITS file with calibrated visibilities, 
applies these corrections as a priori and writes updated <B>total</B> gain 
correction with respect to a case when no gain correction is applied. 
Thus, if to run <EM class="task">gaco</EM> task more than once, the result 
will be approximately the same.

<A NAME="splt_uc">
<H2> Use case of preparing the data suitable for imaging</H2>

  The imaging analysis and absolute astrometry/geodesy pipeline has 
a common beginning: loading the data; parsing log files, checking
logs, checking phase calibration, cleaning phase calibration for
spurious tones, checking autocorrelation, checking Tsys; running
coarse fringe fitting, computation of the bandpass, running
fine fringe fitting. After that point the pipelines diverge.
Next task will be selecting good reference sources and running task
<EM class="task">splt</EM> for them. A good reference source is strong, 
observed at all baselines and has relatively simple structure.
<P>

  It is first recommended to run <EM class="task">splt</EM> task 
<I>for several reference sources</I> with <EM class="com">DEBUG_LEVEL</EM>: 
<EM class="val">2</EM> or <EM class="val">3</EM> and with 
<EM class="com">FRIB.SNR_DETECTION</EM>: <EM class="val">6.0</EM>. It is 
recommended to investigate the <EM class="task">splt</EM> log 
file. Search there for lines with <TT>PIMA_SPLT_FITSTA  SOU:</TT>, 
for instance with using grep. This line provides the statistics for a 
subarray. (Remember: a scan may have one or more subarrays that can be 
later consolidated into one subarray). An analyst should examine the 
column followed by <TT>MaxDev_Gr_Del</TT>. This column provides the maximum 
residual of transforming baseline-dependent group delay to the station-based. 
Typical value of this residual for a <B>detected source</B> is 
50&ndash;300 ps. A source with complicated structure may have residual 
1 &ndash; 2 ns. But a residual, say 1000 ns, indicates that at least one 
observation in the subarray was a <B>non-detection</B>. Even one non-detection 
can spoil entire dataset for a given source to a level of uselessness. If you 
see large maximum  residual in the subarray statistics, just look in the 
preceding lines that start with <TT>PIMA_SPLT_FITSTA  Sou:</TT>. Identify 
sources with large residuals (say more than 12 &ndash 3 ns), identify their 
observation indices that can be found in the column followed by 
<TT>OBS:</TT>, and add these observation indices to the exclude file. Then 
run <EM class="pima">PIMA</EM> task <EM class="task">splt</EM> with specifying 
this file in keyword <EM class="com">EXCLUDE_OBS_FILE</EM> once again. 
Then inspect the log file again.
<P>

  After inspection shows no subarray with large residuals, the selected
reference sources are imaged using phase and amplitude self-calibration. 
If for some reason an image of one of the reference sources is not
satisfactory, another that bad source should be replaced with another
source. 
<P>

  When good images were produced for all reference sources, 
<EM class="pima">PIMA</EM> task <EM class="task">gaco</EM> is invoked with 
qualifier <EM class="val">sou</EM> with the comma-separated list of 
reference sources. After that the gain correction file is inspected.
If some IFs at some stations are to be masked out, corresponding 
values of the gain correction file are replaced with zeroes.
<P>
 
  After that task <EM class="task">splt</EM> runs over entire dataset by 
specifying <EM class="com">SPLT.SOU_NAME</EM>: <EM class="val">ALL</EM>. 
A care must be taken to use only detected observations. There are two 
approaches for cleaning the dataset for non-detections. The first approach 
is to raise the SNR detection limit defined by keyword 
<EM class="com">FRIB.SNR_DETECTION</EM>. Depending on the search window,
the detection limit is 5.3&ndash;6.0, the wider the window the higher 
the limit. Another approach is to run full absolute astrometry/geodesy 
pipeline and exclude those observations that are flagged out by 
Post-Solve. Solve will flag non-detections and other "bad" observations, 
such as those affected by RFI, low fringe rate problem, etc.
Extraction of the list of observations that is performed by program
gvf_db that is a part of Solve package. Usage: 
<PRE>
    gvh_db database_name mode
</PRE>

   where mode is either 10 for a processing a single-band experiment 
or the upper band of a dual-band experiment and 20 is for processing
lower band of a dual-band experiment. The advantage of the second
approach is that detections as weak as 4.8 can be used since Post-Solve
will eliminated non-detections and other bad detections. Re-fringing
allows to recover weak detections. The  disadvantage is that Post-Solve 
should be installed, and running astrometry analysis requires extra
efforts.
<P>

   After running <EM class="task">splt</EM> over the entire dataset, 
the <EM class="task">splt</EM> log should
be examined the same way as we did when we processed reference 
sources.
<P>

  Task <EM class="task">splt</EM> creates calibrated visibilities of all 
the sources, except those that have too few detections and put then in 
directory <TT>SSSSS/EEE_uvs</TT>. Calibrated visibilities are used for 
imaging with DIFMAP, AIPS or another software. Result of imaging are two 
files per source: a file with self-calibrated visibilities in FITS format 
and image in FITS image format. The image contains two tables: a set of 
CLEAN components and the binary image that was generated from the table 
of CLEAN components. 
<P>

<A NAME="opag"> 
<H2> OPAcity Generation </H2>
<P>

  Task <EM class="task">opag</EM> provides and interface to the 
SPD (Slant Path Delay) package for computation of opacity and atmosphere 
brightness temperature using the output of numerical weather models. 
This task accesses a remote Web server, downloads data files with
slant path delays, opacitites, and atmospheric brightness temperatures,
and stores then in directory <TT>SSSSSS/EEE_sob</TT>
<P>

  Keyword <EM class="com">spd_url</EM> is required. It specifies
the URL where the datafiles with atmosperic opacity and brightness
temperature are stored. Recommended web-site:
<A HREF="http://atmospheric-propagation.smce.nasa.gov/spd/asc/geosit">
http://atmospheric-propagation.smce.nasa.gov/spd/asc/geosit</A>.
<P>

<A NAME="opal"> 
<H2> OPAcity Loading </H2>
<P>

  Task <EM class="task">opal</EM> parses the files with opacity and 
brightness temperature on the 3D elevation-azimuth-time grid created by
package <A HREF="http://astrogeo.org/spd">SPD</A> that was invoked by
task <EM class="task">opag</EM>, interpolates them for the scan start
and scan end and writes down into <EM class="pima">PIMA</EM> internal 
data structure. It also computes receiver temperature Trec by subtracting 
atmosphere temperature from measured system temperature.
Task <EM class="task">opal</EM> also initializes arrays with so-called 
modeled and cleaned system temperature, i.e. removes if they existed 
before, fills them zero and sets flags "not available".

<A NAME="tsmo"> 
<H2> Compute TSys MOdel </H2>
<P>

   Task <EM class="task">tsmo</EM> computes the so-called modeled Tsys.
This task works in two modes, "<TT>elevation</TT>" mode and 
"<TT>if</TT>" mode. 
<P>

  In the "if" mode the task flags Tsys values that violate the assumption 
that the ratio of Tsys between IFs of the specified band is constant 
in time for a given experiment. First, <EM class="pima">PIMA</EM> finds
the reference IF within the band specified by keywords 
<EM class="com">BEG_FRQ</EM> and <EM class="com">END_FRQ</EM>. It tries
 the IFs one by one. It computes the logarithms of the the ratio of Tsys
of a given IF to the Tsys of the reference IF, finds the median ratio,
computes the rms of the deviation and removes the outliers that are
<EM class="com">FRIB.NOISE_NSIGMA</EM> times greater than the rms.
The trial reference IF that has the minimum number of outliers becomes
the reference IF. After that <EM class="pima">PIMA</EM> computes 
the average Tsys ratios and stores flags. In a case if for a given
observation Tsys at the reference IF has to be flagged, a temporary
reference IF is sought.
<P>

  In the "elevation" mode the task decomposes Tsys into the product
<TT> T_sys = T_o * a(t) * b(e)</TT>
<P>
   where  
    OL> 
       <LI> a(t) is a function of time represented by a linear spline;  
            </LI><BR>
       <LI> b(e) is a function of elevation represented by linear spline. 
            </LI><BR>
       <LI> T_o  is the minimal system temperature.                         
            Functions a(t) and b(e) are normalized to have minimal      
            value 1.0
            </LI><BR>
   </OL><BR>
                                                                      
Parameter T_o and coefficients of the spline a(t) and b(e) are found by 
iterative non-linear LSQ. Outliers are detected and flagged out during
this procedure. If <EM class="task">tsmo</EM> task in "<TT>if</TT>" mode 
ran before, the input for this procedure is the geometric average 
of Tsys, except those that were previously flagged out, i.e.
<TT>T = (&Pi; Tsys(i))^(1/n)</TT>. Otherwise, Tsys for 
<EM class="com">BEG_FRQ</EM> is taken. It is strongly recommended first
to run <EM class="task">tsmo</EM> task in "<TT>if</TT>" mode and then
in "<TT>elevation</TT>" mode since the latter mode is less stable to 
outliers. Potentially, a large outlier(s) can distorts significantly 
the solution.
<P>

   After the task <EM class="task">tsmo</EM>  computes Tsys decomposition,
it computes the so-called modeled Tsys using parameters of the decomposition
for start and stop date of every scan and stores it in the appropriate
slot. In addition, <EM class="pima">PIMA</EM> computes so-called cleaned
array of Tsys. Cleaned Tsys coincides with modeled Tsys for the points
with missing or flagged measured Tsys and coincides with measured Tsys
for all other points.
<P>

   Task <EM class="task">tsmo</EM> requires keyword <EM class="com">mode</EM> 
that accepts comma separated values <EM class="val">if</EM> and 
<EM class="val">elev</EM>. Unless a user has reasons to do otherwise,
it is recommended to use both keywords: <EM class="task">tsmo</EM> 
<EM class="com">mode</EM> <EM class="val">if,elev</EM>. When two
values are specified, <EM class="pima">PIMA</EM> will first execute
Tsys model computation in the "<TT>if</TT>" mode and then in 
"<TT>elevation</TT>" mode.
<P>

   For experiments with two band, for instance S/X or C/X, task 
<EM class="task">tsmo</EM> should run for two bands separately since the 
ration of Tsys between IFs of different receivers may change. Elevation 
dependence is frequency dependent, and therefore, should be modeled 
separately.
<P>

   Results of task <EM class="task">tsmo</EM> can be examined with 
task <EM class="task">tspl</EM>. When task <EM class="task">tspl</EM>
is invoked with keyword <EM class="com">TSYS:</EM>
<EM class="val">MEASURED</EM>, it will show measured Tsys. When it 
is invoked with <EM class="com">TSYS:</EM> <EM class="val">MODELED</EM>
it will show modeled Tsys. When it is invoked with 
<EM class="com">TSYS:</EM> <EM class="val">CLEANED</EM>, it will show 
modeled Tsys. In general, <EM class="com">TSYS:</EM> 
<EM class="val">CLEANED</EM> is recommended: from one hand, measured
Tsys is used. From the other hand, obvious Tsys outliers are eliminated.
<P>

   It should be remembered that <EM class="task">opal</EM> purges results 
of task <EM class="task">tsmo</EM> and task <EM class="task">load</EM> 
purges results of both tasks <EM class="task">opal</EM> and
<EM class="task">tsmo</EM>.

<A NAME="auto_image"> 
<H2> Automatic imaging
</H2>

   In principle, totally automatic imaging is feasible, but development
such a system would require an order of magnitude more efforts than
it was invested in <EM class="pima">PIMA</EM>. Therefore,
<EM CLASS="pima">PIMA</EM> provides partially automatic imaging capability. 
In the framework of the approach implemented in <EM class="pima">PIMA</EM>, 
a user runs fringe fitting, runs astrometry/geodesy solution with 
Post-Solve, runs task <EM class="task">onof</EM>, runs 
<EM class="task">splt</EM>  for 2&ndash;4 reference sources, produces 
their images manually, runs task <EM class="task">gaco</EM>, and then 
runs wrapper script <EM class="wrap">pf.py</EM> task 
<EM class="task">map</EM>. Task <EM class="task">map</EM> of 
<EM class="wrap">pf.py</EM> wrapper invokes 
<EM class="pima">PIMA</EM> task <EM class="task">gain</EM>, 
<EM class="task">splt</EM>, calls DIFMAP in a batch mode, generates images 
of all sources, and creates pictures of all imaged sources in gif 
format. <EM class="wrap">pf.py</EM> scripts puts calibrated visibilities, 
images, self-calibrated visibilities, images, pictures of source images, and 
pictures of scan-averaged flux densities as a function of baseline
lengths into directory <TT>SSSSS/EEE_uvs</TT>, were <TT>SSSSS</TT> is the 
<EM class="pima">PIMA</EM> scratch directory specified in the keyword 
<EM class="com">EXPER_DIR</EM> and <TT>EEE</TT> is the experiment name 
specified in the keyword <EM class="com">SESS_CODE</EM>. 
<EM class="pima">PIMA</EM> generates the for each source with enough usable 
data the following files:
<UL>
    <LI>calibrated visibilities with name <TT>JJJJJJJJJJ_B_uva.fits</TT>
        </LI>
    <LI>slef-calibrated visibilities with name <TT>JJJJJJJJJJ_B_uvs.fits</TT>
        </LI>
    <LI>brightness distributions with name <TT>JJJJJJJJJJ_B_map.fits</TT>
        </LI>
    <LI>picture of image <TT>JJJJJJJJJJ_B_map.gif</TT>
        </LI>
    <LI>picture of scan-averaged self-calibrated visibility as a function
        of baseline length <TT>JJJJJJJJJJ_B_rad.gif</TT>
        </LI>
</UL>
 where <TT>B</TT> is the band specified in keyword BAND, 
<P>

  Quality of automatically generated images not always satisfactory. 
Most common reasons: a) not all visibilities when the antennas were off
are filtered out; b) visibilities at some IFs require significant 
corrections, say more than 50%, c) non-detection visibilities used by
<EM class="task">splt</EM>; d) the source is larger than the default field 
of view. Therefore, automatically generated images require scrutinizing.
Recommended approach: an analyst using utility gqvew screens pictures of 
images and self-calibrated visibilities and selects those sources which
images look suspicious. These selected sources are imaged manually.
It is recommended to adhere the same name conventions of output files that
<EM class="pima">PIMA</EM> uses.


<A NAME="samb"> 
<H2> Re-fringe the data using results of astrometry/geodesy solution </H2>

  In general, an iteration <EM class="pima">PIMA</EM> &rarr; Post-Solve 
&rarr; <EM CLASS="PIMA">PIMA</EM> is required.
Interactive Post-Solve is used for a) setting up parameterization; 
b) outliers elimination; c) re-weighting; d) setting up constraints. 
Results of Post-Solve are written in the database during operation 
"database update" (Cntrl/U). Observation suppression status is kept in 
the database. This information can be extracted and used for excluding 
suppressed observations by task <EM class="task">splt</EM>. Sole suppresses 
observations with residuals greater than some limit, typically 
3&ndash;4 &sigma;. There are several reasons why an observation may have 
a large residual: a) deficiency in the theoretical model; b) low fringe 
rate that results in <EM class="pima">PIMA</EM> selecting correlation 
between phase-calibration signal; c) <EM class="pima">PIMA</EM> picking up 
a local maximum in the Fourier transform of visibilities. If the residual 
is caused by deficiency in the ionosphere or atmosphere model, such an 
observation is "bad" for astrometry/geodesy, but good for imaging. If the 
a priori source position used by <EM class="pima">PIMA</EM> had a large 
error, say more than 0.5"&ndash;1", a quadratic term in residual fringe 
phase appears, group delay is biased, and the SNR is reduced. This problem 
can be alleviated if fringe fitting is repeated with corrected a priori 
source position. <EM class="pima">PIMA</EM> checks the difference between 
the source position used by the correlator and the a priori used by 
<EM class="pima">PIMA</EM> that it takes from the supplied catalogue. 
If the differences exceeds a certain threshold <EM class="pima">PIMA</EM> 
computes phase correction that compensate the quadratic term. This usually 
fixes the problem. NB: the dataset should be reloaded in order to change 
in the a priori source catalogue to take effects. Similarly, if a source 
position used by the correlator was correct, but the source position in 
the <EM class="pima">PIMA</EM> catalogue is wrong, f.e. due to a typo 
or wrong source association, <EM class="pima">PIMA</EM> will apply 
wrong correction and may spoil data  that are good otherwise.
<P>

  If an observation is suppressed because <EM class="pima">PIMA</EM> picked 
wrong maximum in the Fourier transform of visibilities, it is possible to 
correct it. We can predict group delay rather precisely after Post-Solve 
solution: several nanoseconds at 2 GHz and several hundreds picoseconds at 
8 GHz and higher. Therefore, we can guide <EM class="pima">PIMA</EM> where 
to search for the maximum and fringe affected data once more. This 
procedure is called re-fringing. 
<P>

  Solve has a special mode that prints residuals and a priori delay computed
by VTD. To turn this mode, hit key <B>A</B> at the "Last page" menu and 
rewind spool file (Find "menu 1" set (C)hange Spooling current: on and
hit key <B>;</B> to rewind the spool file with solution listing, i.e. to purge 
its previous contents. After that just run LSQ solution by hitting  key <B>Q</B>,
scroll the listing by hitting blank key two times and leave Post-Solve by 
hitting key <B>T</B>. Then copy the spool file into the experiment directory 
under name <TT>EEE_B_init.spl</TT>, where <TT>EEE</TT> is the experiment name
and <TT>B</TT> is band. Using information in the residual file, one can
construct command line for <EM class="pima">PIMA</EM> with modified keywords
<EM class="com">FRIB.DELAY_WINDOW_CENTER</EM>, 
<EM class="com">FRIB.RATE_WINDOW_CENTER</EM>, 
<EM class="com">FRIB.DELAY_WINDOW_WIDTH</EM>,
<EM class="com">FRIB.RATE_WINDOW_WIDTH</EM> in such a way that 
<EM class="pima">PIMA</EM> will search for the maximum within 1&ndash;3 ns 
of the group delay predicted on the basis of Post-Solve  solution. Program 
samb that is a part of Post-Solve package does this for you.
<P>

  Usage:
<PRE>
 samb -p {pima_control_file} -w {window_semi_width_in_nsec} -s {snr_min) 
      -r {residual_file} -o {output_file}
</PRE>
  Parameter <TT>pima_control_file</TT> is the name of 
<EM class="pima">PIMA</EM> control file. Parameter 
<TT>window_semi_width_in_nsec</TT> is new window for group delay search. 
Recommended value is 5 times the wrms of residuals. Parameter <TT>snr_min</TT> 
is the new SNR limit. Recommended value 4.8. Parameters <TT>residual_file</TT> 
is the fike with residuals generated by Post-Solve. Finally, parameter 
<TT>output_file</TT> specifies the name of the output command file.
<P>

  Program samb analyzes the file with Post-Solve residuals, finds outliers
marked by character &gt; or <TT>R</TT> in the 8th column, computes the
expected residual group delay delay with respect to the a priori
model used by the correlator, which in general is different than 
a priori models used by VTD plus adjustments found by Post-Solve, and
uses this value for <EM class="com">FRIB.DELAY_WINDOW_CENTER</EM> argument 
for <EM class="pima">PIMA</EM> command line for re-fringing.
<P>

   We need to save Post-Solve solution before running 
<EM class="pima">PIMA</EM> by hitting <TT>CNTRL/U</TT> key. Then we execute 
the command line generated  by <EM class="pima">PIMA</EM>. Re-fringing may 
or may not find correct maximum in the Fourier transform of visibility data. 
The control file generated by samb writes the results in file 
<TT>VVVVV/EEE/EEE_B_refri.fri</TT> and residuals in 
<TT>VVVVV/EEE/EEE_B_refri.frr</TT>, where <TT>VVVVV</TT> is the 
<EM class="pima">PIMA</EM> scratch directory, <TT>EEE</TT> is the experiment 
name specified in the keyword <EM class="com">SESS_CODE</EM> of the 
<EM class="pima">PIMA</EM> control file, and <TT>B</TT> is the band name.
<P>

  Next step is to extract records in the output fringe output and
fringe residual files generated by the command file created by samb, 
and to add those that have SNR greater than the limit specified by samb
command <I>to the end</I> the main fringe results and fringe residual 
files. Remember, process fringe results file consecutively. If there 
is more than one record corresponding to the same observation, the 
latest record overrides the previous record(s).
<P>

  Next step is to create a GVF database using updated files with 
fringe results and fringe residuals with <EM class="pima">PIMA</EM> 
task <EM class="task">mkdb</EM>. There is a caveat. When we updated 
the database, it stores auto suppression and user suppression flags. 
These flags store the status of observations before re-fringing. 
Re-fringing may change observation status: an observation that was 
considered non-detection in the first fringing, may become detected 
in the re-fringing. Post-Solve does not allow to change status of 
an observation marked as non-detection. Program <TT>gvf_supr_promote</TT>
solves this problem. It updates flags "not detected". If an 
observation was not detected in the first fringing, but detected 
during re-fringing, the flag "not detected" is cleared and flag 
"suppressed" is set. Program <TT>gvf_supr_promote</TT> is a part of 
Post-Solve. It accepts the full database name, including and extension 
</TT>.env</TT>, as an argument. Alternatively, the same operation 
can be performed with wrapper <EM class="wrap">pu.py</EM>. 
Wrapper <EM class="wrap">pu.py</EM> has two arguments: experiment 
name and band.
<P>

  Operations samb, <EM class="pima">PIMA</EM>, and update of suppression 
flags can be performed with wrapper <EM class="wrap">pr.py</EM>. 
Wrapper <EM class="wrap">pr.py</EM> requires as the 
first argument the experiment name, as the second argument
low case band, as the third argument the SNR limit. Depending
on band, <EM class="wrap">pr.py</EM> will select delay window semi-width. 
The delay semi-width can be overridden with optional argument 
<EM class="com">-delwin</EM>. Optional flag <EM class="com">-nodb</EM>
causes the wrapper to update only fringe results without creation of 
a database. This option is necessary when a low band of a dual-band 
experiment is re-fringed.
<P>

  After the database is updated, it should be processed with Post-Solve 
once more. Some observations that were previously suppressed as outliers
(ideally all)  can be restored. Observations that were considered as
non-detections and therefore were considered as unrecoverable if
detected during re-fringing appears as "bad", but recoverable. 
Post-Solve program ELIM in restoration mode should be executed and the
database be updated. Usually, there is no need to make a next 
iteration, unless an error has been made that should be corrected. 
<P>

<A NAME="ag_pipe"> 
<H2> Data analysis pipeline </H2>

   The recommended pipeline consists of three steps: 1) fringe fitting;
2) astrometry/geodesy; 3) imaging. Step astrometry/geodesy can be used
for imaging analysis or can be skipped.

<H2> Fringe fitting pipeline </H2>

<A NAME="fri_pipe"> 
<OL>
   <LI> Create <EM class="pima">PIMA</EM> configuration file for 
        the experiment. 
        </LI><P>

   <LI> Load FITS-IDI data. Command: <EM class="wrap">pf.py</EM> 
        <EM class="com">EEE B load</EM>. 
        </LI><P>

   <LI> Parse log files. Not needed for processing VLBA data
        after 2014. Command: 
        <EM class="wrap">pf.py</EM> <EM class="com">EEE B logs</EM>. 
        </LI><P>

   <LI> Load calibration information into <EM class="pima">PIMA</EM> 
        internal data structure. Not needed for processing VLBA data 
        after 2014. Command: <EM class="wrap">pf.py</EM> 
        <EM class="com">EEE B gean</EM>. 
        </LI><P>

   <LI> If all phase calibration tones are extracted, run automatic phase
        calibration masking with  <EM class="pima">PIMA</EM> 
        task <EM class="task">gepm</EM>, then examine
        phase-cal with <EM class="pima">PIMA</EM> task 
        <EM class="task">mppl</EM>. Check phase cal tones 
        for all the stations. If additional spurious signals are found, 
        add the infected tones to the mask definition file and translate
        the mask definition file to a phase cal mask using task 
        <EM class="task">pmge</EM>. Iterate the process till 
        plots of phase calibration show satisfactory results. 
        If 1 or 2 tones are IF are extracted, check 
        phase calibration with task <EM class="task">pcpl</EM>. If phase 
        calibration for some stations is too noisy, disable phase cal for 
        these stations with task <EM class="task">gean</EM>.
        </LI><P>

   <LI> Rug coarse fringe fitting. Command: 
        <EM class="wrap">pf.py</EM> <EM class="com">EEE B coarse</EM>. 
        </LI><P>

   <LI> Run bandpass generation in the inspection mode.
        Command <EM class="wrap">pf.py</EM> <EM <EM class="val">exp band bpas -insp</EM>
        To examine cross and auto spectrum. To create bandpass mask definition 
        file. Transform mask definition file into the bandpass mask file with 
        command <EM class="task">bmge</EM>. Run command 
        <EM class="wrap">pf.py</EM> <EM class="com">EEE B bpas -insp</EM>. 
        again and check that masking bad auto- and cross- correlation channels 
        fixed the problem. Update the band definition file if needed and iterate.
        </LI><P>
 
   <LI> Run bandpass generation in the non-interactive mode. Examine
        the log. Check observations that are marked as outliers. If needed,
        update the mask definition file, disable phase calibration, and
        repeat.
        </LI><P>
  
   <LI> Run fine fringe fitting in fine mode. Command: 
        <EM class="wrap">pf.py</EM> <EM class="com">EEE B bpas fine</EM>. 
        </LI><P>
</OL>

<A NAME="astro_pipe"> 
<H3> Pipeline for astrometry/geodesy data analysis </H3>

This pipeline runs <I>after</I> the fringe fitting pipeline.

<OL>
   <LI> Export the results of fringe fitting into GVF database.
        </LI><P>

   <LI> Run astrometry/geodesy solution using VTD/Post-Solve.
        </LI><P>

   <LI> Suppress outliers that include but not limited to non-detections
        using Post-Solve.
        </LI><P>

   <LI> Store the GVF database using Post-Solve. </LI><P>

   <LI> Store the full residual file </LI><P>

   <LI> Run Post-Solve program samb that generates the control file 
        that calls <EM class="pima">PIMA</EM> for re-fringing suppressed 
        observations; run re-fringe with <EM class="pima">PIMA</EM>; 
        select the observations with SNR above the detection threshold and 
        append fringe results for these observations to the end of fringe
        file; create a new GVF database version 1 using 
        <EM class="pima">PIMA</EM> task <EM class="task">mkdb</EM>; propagate 
        auto suppression status to the database. All these steps are executed 
        by wrapper <EM class="wrap">pr.py</EM>.
        </LI><P>

   <LI> Run VTD/Post-Solve solution once again. Suppress outliers and restore 
        good observations marked as outliers.
        </LI><P>

</OL>

<A NAME="ima_pipe"> 
<H3> Imaging pipeline </H3>

  It is recommended to run imaging pipeline after fringe fitting pipeline
and astrometry/geodesy pipeline. The latter pipeline allows you to
effectively filter out non-detections and corrupted observations,
f.e. observations where the fringe fitting algorithm found the maximum
that corresponds to correlation of phase calibration signal. Though
it is possible to skip astrometry/geodesy pipeline, but in that case
you need to screen observations for non-detections or observations'
where fringe fitting failed. Setting a higher SNR limit in a range 
6.0&ndash;6.5 seems prudent. NB: even one non-detection that slipped
into the dataset may severely distort an image.

<OL>
   <LI> Import gain table.
        </LI><P>

   <LI> Run <EM class="pima">PIMA</EM> task <EM class="task">onof</EM>.
        </LI><P>

   <LI> Extract indices of suppressed observations in VTD/Post-Solve
        solution in an ascii to use this file as value of the keyword
        <EM class="com">EXCLUDE_OBS_FILE</EM>.
        </LI><P>

   <LI> Import antenna gain.
        </LI><P>

   <LI> Select 2&ndash;5 strong sources that were observed at all 
        baselines. Run task <EM class="task">splt</EM> for these sources. 
        Check <EM class="task">splt</EM> logs. If there are observations with 
        large residual group delays, add their indices to the file pointed by 
        keyword <EM class="com">EXCLUDE_OBS_FILE</EM>, and repeat task 
        <EM class="task">splt</EM> one more time.
        </LI><P>

   <LI> Image selected sources.
        </LI><P>

   <LI> Run task <EM class="task">gaco</EM> for imaged sources. Examine gain 
        correction file and edit it, if necessary.
        </LI><P>

   <LI> Run task <EM class="task">splt</EM> for all the sources. Check 
        <EM class="task">splt</EM> logs. If there are observations with large 
        residual group delays, add their indices to the file pointed by keyword 
        <EM class="com">EXCLUDE_OBS_FILE</EM>, and repeat task 
        <EM class="task">splt</EM> one more time.
        </LI><P>

   <LI> Image all the sources. You may want to copy to another directory
        results of imaging strong calibrator that you run before, since
        <EM class="pima">PIMA</EM> will overwrite them otherwise.
        </LI><P>

   <LI> Create pictures of the brightness distribution of the imaged sources.
        </LI><P>
</OL>

   The three last three steps are performed by wrapper 
<EM class="wrap">pf.py</EM> <EM class="com">EEE B map</EM>. 

<A NAME="pir"> 
<H2> Running the analysis pipeline with pir.py</H2>

  Program <EM class="wrap">pir.py</EM> is provided for facilitating
running the VLBI analysis pipeline in the semi-automatic fashion.
As of 2021, the fully automated mode is not yet implemented.
However, <EM class="wrap">pir.py</EM> substantially reduces the
amount of manual work. It executes elements of the VLBI data 
analysis pipeline. In total, there are 16 elements. Elements 
can be executed separately, or in the group, or all together.

<PRE>
   usage: pir.py [-h] [--version] [-v verbosity] [-b band]            
                 [-r run-level] [-s] experiment
</PRE>
 
   where experiment is the experiment code following either NRAO,
         or KVN, or IVS, or KaVA, or EAVN notation.
<P>
 
   parameter <EM CLASS="val">--verbosity</EM> controls verbosity of the output.
   <UL>
         <LI>    0 -- silent </LI><P>
         <LI>    1 -- normal verbosity (defaults) </LI><P>
         <LI>    2 -- debugging mode. </LI><P>
   </UL>
<P>
   parameter <EM class="val">--band</EM> specifies the 1-character long 
             band name. If the experiment has two bands, the code for 
             the upper band should be used.
<P>
 
   parameter <EM class="val">--run-level</EM> controls which elements 
             or a group of elements of the VLBI data analysis pipeline 
             should be executed. The run-level is either a positive
             number when an elementry run level is specified or 
             a low case letter if a compound run level is selected.
             See the next subsection.
<P>

   If parameter <EM class="val">-s</EM> was specified, statically linked 
<EM class="pima_font">PIMA</EM>  will be used.
<P>

  If the experiment has data from two bands, both bands will be processed
to enable the use of ionosphere-free combinations of group delay 
observables. The upper band should be specified when running 
<EM class="wrap">pir.py</EM>.
<P>

   Limitations:
   <OL>   
      <LI> The full end-to-end pipeline without manual intervention
           is not yet feasible. More work needs be done to implement it.
           As of version 1, there are several breaking points that assume
           manual work. </LI><P>

     <LI>  As of version 1, lin-pol 4 band observations are not yet
           supported. </LI><P>
   </OL>

<A NAME="pir_run_levels"> 
<H3> pir.py run levels </H3>

   Program <EM class="wrap">pir.py</EM> splits the VLBI data 
analysis pipeline into a number of run levels. The run levels are supposed 
to be executed in the defined order because results  from the previous run 
levels are used for the next run level. The run levels can be elementary 
or compound. Compound run levels combine several elementary run levels. 
The granulation of the pipeline into elementary and compound run levels 
provides flexibility. For some data analysis scenarios compound run levels 
can be used, for other scenarios additional programs need run between 
elementary run levels.

<P>

  The following run levels are supported:
<BR>

   <OL> 
       <LI> Load the experiment to <EM class="pima">PIMA</EM>.
            </LI><P>

       <LI> Generate bandpass and phase calibration masks from
            mask definitions files.
            </LI><P>

       <LI> Parse logs and load information extracted from 
            logs to <EM class="pima">PIMA</EM>.
            </LI><P>

       <LI> Run coarse fringe fitting.
            </LI><P>

       <LI> Run bandpass generation.
            </LI><P>

       <LI> Run fine fringe fitting.
            </LI><P>

       <LI> Run creation of an output GVF database.
            </LI><P>

       <LI> Run pSolve using version 2 of the GVF database and generate 
            listing of the solution. <B>NB:</B> It is assumed 
            interactive data preprocessing with pSolve has been done
            prior that step.
            </LI><P>

       <LI> Run re-fringing of the observations marked as outliers 
            during preprocessing.
            </LI><P>

       <LI> Run creation of an output GVF database with re-fringed data.
            </LI><P>

       <LI> Run task onof to determine segments of data when antenna 
            was not on source.
            </LI><P>

       <LI> Run computation of atmosphere brightness temperature and 
            opacity using the output of numerical weather model. 
            <B>NB:</B> You need to have the preprocessed output of the 
            output of numerical weather model at your local computer 
            to run this task. Automatic downloading these data will 
            be implemented in the future.
            </LI><P>

       <LI> Run loading atmospheric opacity and brightness temperature
            followed by automatic editing of raw Tsys values.
            </LI><P>

       <LI> Generate images of the sources selected as reference.
            </LI><P>

       <LI> Run gain correction computation using images of reference 
            sources.
            </LI><P>

       <LI> Run automatic imaging.
            </LI><P>
   </OL>

  The following compound run levels are supported:
  <UL> 
       <LI> <EM class="val">l</EM> &mdash; extended loading.
            It combines 1,2,3 and performs loading the experiment, 
            generation of the  bandpass and phase calibration masks 
            from mask definitions files, parsing Fields System log files,
            and loading extracted calibration information into 
            <EM class="pima">PIMA</EM>.
            </LI><P>

       <LI> <EM class="val">c</EM> &mdash; coarse fringe fitting. 
            The same as 4.
            </LI><P>

       <LI> <EM class="val">b</EM> &mdash; bandpass computation.
            The same as 5.
            </LI><P>

       <LI> <EM class="val">f</EM> &mdash; fine fringe fitting. 
            Includes fine fringe fitting and generation of the GVF
            database at the end. Combines 6 and 7.
            </LI><P>

       <LI> <EM class="val">r</EM> &mdash; re-fringing. It runs 
            pSolve solution, uses pSolve residuals to generate
            control files for re-processing the outliers of the 
            pSolve solution with a narrow window, runs re-fringing,
            and generates the re-fringed database.
            Combines 8, 9, and 10.
            </LI><P>
            
       <LI> <EM class="val">p</EM> &mdash; pre-imaging.
            Includes determination of data segments when antennas were not 
            on source; computation of the atmospheric opacity and brightness
            temperature; automatic editing Tsys that includes outlier
            elimination and interpolation of bad or missing Tsys; loading
            modeled Tsys into <EM class="pima">PIMA</EM>; getting gain and
            loading into <EM class="pima">PIMA</EM>; and generation of 
            files with time and frequency averaged data in FITS image format
            for reference sources. Combines 10, 11, 12, 13, and 14.
            </LI><P>
            
       <LI> <EM class="val">i</EM> &mdash; imaging. Includes computation of
            gain correction, calibration of the data, time and frequency
            averaging, splitting the data into calibrated FITS-file, one file
            per source and band, automatic image generation with Difmap,
            and generation of rad plot and PostScript pictures from images.
            Combines 15 and 16.
            </LI><P>
  </UL>

<A NAME="pir_use"> 
<H3> Hints for pir.py use </H3>

   The pipeline execution still requires manual steps. 
<EM class="wrap">pir.py</EM> reduces the number of manual operations 
to the minimum and automatically runs other steps. The following
sequence is recommended:

<UL> 
    <LI> (<EM class="manual">manual</EM>)
         Download the data and create <EM class="pima">PIMA</EM> control
         file. This step is done manually for processing a new style of
         an experiment. For processing an experiment from a campaign
         that contains many segments, this step can be easily automated. 
         That includes downloading the data and generation 
         of <EM class="pima">PIMA</EM> control files, bandpass 
         and phase calibration masks from templates. The template
         defines most of the parameters using the control files used for
         processing a specific experiment. The rest of the parameters,
         such as experiment name and observing dates, can by automatically
         updated by a simple program.
         </LI><P>

    <LI> (<EM class="automatic">automatic</EM>)
         After the visibility file in FITS-IDI format and VLBI Field System 
         logs are downloaded and named according to the convention 
         <EM class="pima">PIMA</EM> and Psolve understand, task 
         <EM class="wrap">pir.py</EM> with run level 
         <EM class="val">l</EM> is executed.
         </LI><P>

    <LI> (<EM class="manual">manual</EM>)
         Phase cal examination. It is recommended to run manually
         tasks <EM class="task">plcl</EM> and <EM class="task">mppl</EM>.
         The goals is a) to update pcal mask file; b) to find stations for
         which phase calibration is bad and needs be disabled. The stations
         with disabled phase calibration are included in
         as a comma-separated qualifier of <EM class="com">PCAL:</EM> keyword value. 
         <B>NB:</B> If you want to disable phase calibration for a 2-band 
         experiment, do not forget to update <EM class="pima">PIMA</EM> 
         control files for each band. It is advised to run 
         <EM class="wrap">pt.py</EM> for several scans of strong sources to 
         catch other problems than may require editing of control files.
         </LI><P>
        
    <LI> (<EM class="automatic">automatic</EM>)
         Run <EM class="wrap">pir.py</EM> with run level <EM class="val">c</EM>
         to perform coarse fringe fitting. <B>NB:</B> if you have a dual-band 
         experiment, the upper band should be specified. This will cause 
         <EM class="wrap">pir.py</EM> to process both bands in parallel.
         </LI><P>
          
    <LI> (<EM class="manual">manual</EM>)
         Phase cal examination. It is recommended to run manually
         tasks <EM class="task">bpas</EM> via wrapper
         <EM class="wrap">pt.py</EM> with qualifier <EM class="val">-insp</EM>.
         You need decide whether you need adjust bandpass mask, for instance
         to mask out affected IFs either partially or entirely.
         </LI><P>

    <LI> (<EM class="automatic">automatic</EM>)
         Run <EM class="wrap">pir.py</EM> with run level <EM class="val">b</EM>.
         This will generate bandpass file, and for dual-band experiment, 
         the polarization bandpass as well.
         </LI><P>

    <LI> (<EM class="manual">manual</EM>)
         Examine bandpass logs. If bandpass logs show problems, you may
         need adjust control files and/or bandpass or phase calibration masks.
         </LI><P>

    <LI> (<EM class="automatic">automatic</EM>)
         Run <EM class="wrap">pir.py</EM> with run level <EM class="val">f</EM>.
         This will perform fringe fitting and generate version 1 of the experiment
         geodetic database.
         </LI><P>

    <LI> (<EM class="manual">manual</EM>)
         Run pSolve in the mode of interactive preprocessing. Refer pSolve 
         documentation. You need edit both bands of the dual-band experiment,
         At the end you need update the database.
         </LI><P>

    <LI> (<EM class="automatic">automatic</EM>)
         Run <EM class="wrap">pir.py</EM> with run level <EM class="val">r</EM>.
         This will cause re-fringing of all observations. The geodetic database
         will be automatically updated, but the suppression status will not.
         </LI><P>

    <LI> (<EM class="manual">manual</EM>)
         Load version 2 of the experiment and restore good observations that 
         appear after re-fringing using pSolve. Save updated database. 
         Geodetic part of the processing is completed.
         <P>
         If you will image observed sources, you need prepare files with 2&ndash;4
         reference sources at this point. Remember, these files have suffices 
         _{band}_ref.sou, where {band} is a band.
         </LI><P>

    <LI> (<EM class="automatic">automatic</EM>)
         Run <EM class="wrap">pir.py</EM> with run level <EM class="val">p</EM>.
         This will execute task <EM class="task">onof</EM>, update Tsys, and 
         generate files with time and frequency averaged calibrated visibility 
         in FITS image format for reference sources. 
         </LI><P>

    <LI> (<EM class="manual">manual</EM>)
         Image reference sources using Difmap.
         </LI><P>

    <LI> (<EM class="automatic">automatic</EM>)
         Run <EM class="wrap">pir.py</EM> with run level <EM class="val">i</EM>.
         This will automatically generate images of all the sources and generates
         source picture files in GIF format.
         </LI><P>

    <LI> (<EM class="manual">manual</EM>)
         Manually examine the images. Re-image manually poor images.
         </LI><P>
</UL> 

<A NAME="dual"> 
<H2> Processing dual-band observations </H2>

   Dual-band observations are processed separately. Though in some cases
it is possible to run fringe fitting over a very wide bandwidth (several
GHz), in that case this would be called wide-band fringe fitting. Depending
on the correlator setup dual-band data can be be put in one frequency group,
f.e. VLBA S/X observations or observations at remote wings of VLBA C-band
receivers or be put into two different groups. If the frequency layout is not
known, the following parameters should be set <EM class="com">FRQ_GRP</EM>: 
<EM class="val">1</EM>, <EM class="com">BEG_FRQ</EM>: <EM class="val">1</EM>, 
<EM class="com">END_FRQ</EM>: <EM class="val">1</EM> before loading the 
experiment in <EM class="pima">PIMA</EM>. After that, a user should examine 
the frequency file <TT>SSSSS/EEE.frq</TT> created by 
<EM class="pima">PIMA</EM> task <EM class="task">load</EM> and create 
<I>two <EM CLASS="PIMA">PIMA</EM> control files</I> for the upper and lower 
bands. The upper band is considered primary band and the low band is 
considered secondary band. Keywords <EM class="com">BAND</EM>, 
<EM class="com">FRQ_GRP</EM>, <EM class="com">BEG_FRQ</EM>, 
<EM class="com">END_FRQ</EM> should define frequency names frequency indices 
within the frequency band. The control file of the primary (upper) frequency 
band should define the name of the <EM class="pima">PIMA</EM> control file 
for the secondary (lower) frequency band in the keyword 
<EM class="com">MKDB.2ND_BAND</EM>. The value of this keyword should be 
<EM class="val">NO</EM> in the control file for the lower band.
<P>

   <EM class="pima">PIMA</EM> task  <EM class="task">load</EM>, 
<EM class="task">gean</EM>, <EM class="task">pmge</EM>, 
<EM class="task">bmge</EM> are band-independent; other tasks depends 
on the band an should be executed with the appropriate control file. All 
operations in <EM class="pima">PIMA</EM> pipeline, except tasks  
<EM class="task">load</EM>, <EM class="task">gean</EM>, 
<EM class="task">pmge</EM>, <EM class="task">bmge</EM>, and 
<EM class="task">mkdb</EM> are performed two times: first for lower band and 
for upper band. They can run concurrently. Bandpass and phase calibration mask 
files are common for both bands. Task <EM class="task">mkdb</EM> should be 
run for the upper band only. When <EM class="pima">PIMA</EM> finds value of 
<EM class="com">MKDB.2ND_BAND</EM> that is the <EM class="pima">PIMA</EM> 
control file for the lower band, it computes the total observables of two 
control files and puts them in appropriate slots of GVF database. 
NB: <EM class="pima">PIMA</EM> does not check which band is upper and 
which band is lower frequency &mdash; an analyst should define it. If to 
run <EM class="pima">PIMA</EM> task <EM class="task">mkdb</EM> with the control 
file for the lower band, <EM class="pima">PIMA</EM> will create the GVF 
with total observables only for that band. For historical reasons Post-Solve 
always marks the upper band as "X" and lower band as "S" regardless 
the frequency range. 
<P>
  
  Tasks coarse fringe fitting, bandpass generation, and fine fringe fitting
is executed two times, for lower and upper band. Task 
<EM class="task">mkdb</EM> is executed once for the upper band control file 
only. The GVF database created in the dual-band mode contains the data for 
both bands. Using VTD/Post-Solve  two bands are  processed consecutively, 
first the lower band marked as "S" (Data type "GS"), then the upper band 
marked as "X" (Data type "GX"). Two files with residuals are created: the 
upper band and for the lower band. Then wrapper <EM class="wrap">pr.py</EM>
is executed for both bands: first for the lower band and then for the upper 
band. Option <EM class="com">-nodb</EM> should be used with the wrapper for 
the lower band. This option prevents creation of a database for the lower 
band, since such a database would not have the data for the upper band. 
After wrapper <EM class="wrap">pr.py</EM> for the lower band is completed, 
wrapper <EM class="wrap">pr.py</EM>  for the upper band is executed. During 
next VTD/Post-Solve iteration lower band and upper band data are re-analyzed. 
After that a liner combination of the upper and lower band data 
(Data type: "G_GXS") are analyzed.
<P>

  Imaging the upper and lower bands is done separately. Gain control files
should be separate for upper and lower bands.
<P>

  Although GVF format allows to support up to 8 bands, as of 2016.05.05,
VTD/Post-Solve supports only two bands. An experiment with more than
two frequency bands is processed similarly as a dual-band experiment
except <EM class="com">MKDB.2ND_BAND</EM> keyword that should be NO. 
In such case the keyword <EM class="com">MKDB.OUTPUT_NAME</EM> that defines 
the database suffix should be different for each band. Otherwise, 
<EM class="pima">PIMA</EM> task <EM class="task">mkdb</EM> will overwrite
a database for a different band.


<A NAME="aux"> 
<H2> Auxiliary tools </H2>

   <EM class="pima">PIMA</EM> provides a number of tools for examining
the data.

<A NAME="aux_log"> 
<H3> Antenna log processing tool </H3>

    Program <B>log_to_antab</B> processes input log files generated 
by software Field System and writes results in PIMA Antab format.
<PRE>
         Usage: log_to_antab mode log_file antab_file  [year]
</PRE>

   There are three mandatory arguments:
<UL>
    <LI> <EM class="com">mode</EM> &mdash; a flavour of log file. 
         Supported modes:
         <P>
         <UL>
             <LI> mode =  1 &mdash; for IVS log-files after 2008. </LI><P>
             <LI> mode =  2 &mdash; for IVS log-files in approximately 
                  1999&ndash;2002. </LI><P>
             <LI> mode =  3 &mdash; for IVS log-files in approximately 
                  1996&ndash;1996. </LI><P>
             <LI> mode =  4 &mdash; for IVS log-files in approximately 
                  1996&ndash;1999. </LI><P>
             <LI> mode =  5 &mdash; DBBC log file with USB/LSB pairs of 
                  BBCs. </LI><P>
             <LI> mode = 11 &mdash; for KVN log-files</LI><P>
         </UL>
         </LI><P>

    <LI> <EM class="com">log_file</EM> &mdash; file with the log.
         </LI><P>

    <LI> <EM class="com">antab_file</EM> &mdash; output file with results
         of log file processing.
         </LI><P>

    <LI> <EM class="com">antab_year</EM> &mdash; year of observations.
         Old log files did not provide year in the time tag. This 
         optional argument provides missing information.
         </LI><P>

</UL>

<A NAME="aux_idi"> 
<H3> Tools for examining data in FITS-IDI format </H3>

     When you receive the data from the experiment that you intend to
analyze, you first need to examine the data. 
<B>NB:</B> <EM class="pima">PIMA</EM> processes data only in 
<A HREF="ftp://ftp.aoc.nrao.edu/pub/software/aips/TEXT/PUBL/AIPSMEM114.PDF">
FITS-IDI format</A>. <EM class="pima">PIMA</EM> provides several utilities 
that are useful for an initial data check.

<UL>
    <LI> <B>fitsh</B> &mdash; a tool that prints the contents of FITS headers.
         It scans all tables and prints the list of keywords, their format
         and values of keywords (but not contents of the tables).
<PRE>
         Usage: fitsh fits_file
</PRE>
         </LI><P> 

    <LI> <B>fitsd</B> &mdash; a tool that examines a directory with files in 
                      FITS-IDI format and prints start and stop epochs
                      of visibilities that each file contains.
<PRE>
         Usage: fitsd directory file
</PRE>
         </LI><P> 

    <LI> <B>get_source_table_from_fits</B> &mdash; a tool that prints
            the names and coordinates of the sources that are in the 
            specified FITS-IDI file.
<PRE>
         Usage: get_source_table_from_fits fits_file
</PRE>
         </LI><P>

<!--
    <LI> <B>get_freq_table_from_fits</B> &mdash; a that prints the table of 
            frequencies defined in a given FITS-IDI file.
<PRE>
         Usage: get_freq_table_from_fits
</PRE>
         </LI><P>
-->
</UL>

<A NAME="aux_images"> 
<H3> Tools for manipulation with data in FITS image format </H3>

There is a number of tools for processing image data in FITS image format.
<B>NB:</B> these tools will work with the data generated by 
<EM class="pima">PIMA</EM>, AIPS, and DIFMAP. They may or may not work with 
data generated by other programs. There are two level specifications: FITS 
and contents definition. FITS format defines only the data structure at the 
lower level. This information is not sufficient to parse <I>arbitrary</I> 
FITS-file without knowledge of contents definition specifications. 
<P>

  There are four contents definitions formats that <EM class="pima">PIMA</EM> 
deals with:
<OL>
     <LI> FITS-IDI &mdash; format for correlator output. 
          <EM CLASS="PIMA">PIMA</EM> reads this data when executes task 
          <EM class="task">load</EM>. Data in FITS-IDI format contain 
          visibilities and a lot of information that describes the experiment.
          </LI><P>

     <LI> FITS-UVA &mdash; (UV Averaged) format for calibrated visibilities 
          averaged over time and frequency. <EM CLASS="PIMA">PIMA</EM> task 
          <EM class="task">splt</EM> writes the data  in this format. FITS-UVA 
          data contains visibilities, frequency table and information about 
          experiment (name, date, etc). It may or may not contain gain a 
          correction table. <EM CLASS="PIMA">PIMA</EM> adheres file naming 
          convention <TT>JJJJJJJJJJ_B_uva.fits</TT> for FITS averaged visibility 
          data, where <TT>JJJJJJJJJJ</TT> is a 10 character long J2000 source 
          name and <TT>B</TT> is the upper case band name.
          </LI><P>

     <LI> FITS-UVS &mdash; (UV Self-calibrated) format is the same as FITS-UVA, 
          but it contains self-calibrated visibilities after imaging. Visibility 
          amplitudes and phases are corrected by the imaging process. 
          <EM CLASS="PIMA">PIMA</EM> adheres file naming convention 
          <TT>JJJJJJJJJJ_B_uvs.fits</TT> for self-calibrated visibility data.
          </LI><P>

     <LI> FITS-MAP &mdash; format is for storing images. It contains several
          tables: Clean component table, frequency table and the gridded image.
          It also contains some auxiliary information: source name, source
          position, experiment date, beam size, etc. <B>NB:</B> gridded image
          is derived from Clean components. It does not bring additional 
          information and is included to facilitate visualization. General
          purpose FITS viewers will show image in FITS-MAP format.
          </LI><P>
          
</OL>

  The following tools are provided:

<UL>

     <LI> <TT><B> uva_merge </B></TT> &mdash; utility for merging several 
          FITS-UVA visbility data files into one, provided the data have 
          the same frequencies. Merged data may have better uv-coverage 
          and this operation usually improves image quality. Since sources 
          are often variable, merging the data for sources with images 
          that changed is not recommended. For majority of AGNs merging 
          the data with epochs within several months is usually safe.
          <P>

          Usage:
<PRE>
          uva_merge uva_output input1_uva [input2_uva ...]
</PRE>
          Up to 30 FITS files can be merged. The order of input files
          does not matter. Do not forget that the output file comes first!
          
         </LI><P>

     <LI> <TT><B> fits_tim_avr  </B></TT> &mdash; utility for time 
          averaging FITS-UVA calibrated visibility data.
          The output is written in the file in fits format. Time averaging   
          in seconds is specified. <B> fits_tim_avr  </B> starts averaging 
          from  first the visibility till it fills a chunks of tim_av_sec 
          long. Then it coherently averages, updates weights, writes down 
          starts again. Usage:  fits_tim_avr input_uva tim_av_sec output_uva
          where the first argument is the input file, the second argument is 
          the averaging interval in seconds, and the third argument is the   
          name of the output file in fits format.                            

          <P>

          Usage:
<PRE>
          Usage:  fits_tim_avr input_uva tim_av_sec output_uva
</PRE>
          where the first argument is the input file, the second 
          argument is the averaging interval in seconds, and the 
          third argument is the name of the output file in fits format.
          
         </LI><P>

     <LI> <TT><B> fits_to_map  </B></TT> &mdash; utility for generation of
          a picture of the brightness distribution using the Clean component
          table. The picture can be displayed on the display or written 
          in the output file.
          <P>

          Usage:
<PRE>
          fits_to_map [-o output_file] [-box value] [-size code] 
                      [-color code] [-lev value] [-beam code] fits_map_file
</PRE>

          A mandatory argument is map file in FITS-MAP format. Options:
          <P>

          <UL>
             <LI> <EM class="com">-o</EM> &mdash; the  output file. 
                   <EM class="val">XW</EM> means display.
                   If omitted, <EM class="val">XW</EM> is assumed. 
                   Supported extensions:
                   <P>
 
                   <UL>
                       <LI> <EM class="val">.ps</EM>  &mdash; output file will
                            be in Postscript format.
                            </LI><BR>
                       <LI> <EM class="val">.gif</EM> &mdash; output file will
                            be in gif format.
                            </LI><BR>
                   </UL>
                   <P>
                   Unrecognized extension is treated as Postscript.
                   </LI><P>

              <LI> <EM class="com">-box</EM> &mdash; the bounding box size, i.e. 
                    the image scale. The argument specifies the semi-width of 
                    the bounding box in mas. If omitted, fits_to_map will use 
                    the bounding box to show the full image. <B>NB:</B> setting 
                    the bounding box wider than the image size will increase 
                    only the amount of wide space, but will provide no new 
                    information.
                   </LI><P>

              <LI> <EM class="com">-size</EM> &mdash; the image size, one of
                   <P>
                   <UL>
                        <LI> <EM class="val">1</EM> &mdash; 45x45 mm   </LI><BR>
                        <LI> <EM class="val">2</EM> &mdash; 80x80 mm   </LI><BR>
                        <LI> <EM class="val">3</EM> &mdash; 160x160 mm </LI><BR>
                        <LI> <EM class="val">4</EM> &mdash; 270x270 mm </LI><BR>
                   </UL>
                   Fonts and line width are scaled in order to fit the
                   sizes above. By default, image size is <EM class="val">3</EM>,
                   i.e. 160x160 mm.
                   </LI><P>

              <LI> <EM class="com">-color</EM> &mdash; the color index of the 
                   contour map according to DiaGI in a range [-1, 32]. Color 
                   index <EM class="val">-1</EM> indicates the
                   color of the plot the plot will be selected in 
                   accordance with the observing frequency.
                   Color index 0 means black. Program diagi_dec (part of 
                   petools) shows the color table for codes in the range 
                   [1, 32]. By default, color index is <EM class="val">-1</EM>, 
                   i.e. is selected automatically based on observing frequency.
                   </LI><P>

              <LI> <EM class="com">-lev</EM> &mdash; the flux density level for 
                   the first (lowest) contour expressed in image root mean 
                   square noise. Default is <EM class="val">5.0</EM>.
                   
                   </LI><P>

              <LI> <EM class="com">-beam</EM> &mdash; the beam style. One of:
                   <P>
                   <UL>
                        <LI> <EM class="val">0</EM> &mdash; elliptical beam. 
                             The displayed image is stored in the input 
                             FITS-MAP file. </LI><BR>

                        <LI> <EM class="val">1</EM> &mdash; circular beam. 
                             The size of the beam is determined by the 
                             semi-minor axis of the stored elliptical beam. 
                             The displayed image is created by convolving Clean
                             components with the circular beam. </LI><BR>

                        <LI> <EM class="val">2</EM> &mdash; circular beam. The 
                             size of the beam is determined by the semi-major 
                             axis of the stored elliptical beam. The displayed 
                             image is created by convolving Clean components 
                             with the circular beam. 
                             </LI><BR>

                        <LI> <EM class="val">3</EM> &mdash; elliptical circular 
                             beam. The displayed image is created by convolving 
                             Clean components with the elliptical beam. 
                             </LI><BR>

                        <LI> <EM class="val">4</EM> &mdash; delta-function beam.
                             The displayed image is created by convolving Clean 
                             components with the circular beam equal to two 
                             pixels. 
                             </LI><BR>
                   </UL>
                   </LI><P>

          </UL>
          </LI><P>

     <LI> <TT><B> fits_to_radplot  </B></TT> &mdash; utility for generation of
          a picture of the dependence of scan-averaged calibrated visibility
          versus the baseline length (so-called "radplot").
          <P>

          Usage:
<PRE>
          fits_to_radplot [-o output_file] [-size code] [-color code] 
                          [-gap time] [-wei T|F] [-cutoff_err value] [-auto] fits_vis_file
</PRE>

          A mandatory argument is map file in FITS-UVA format. Options:
          <P>
          <UL>
             <LI> <EM class="com">-o</EM> &mdash; the  output file. 
                   <EM class="val">XW</EM> means display.
                   If omitted, <EM class="val">XW</EM> is assumed. 
                   Supported extensions:
                   <P>
 
                   <UL>
                       <LI> <EM class="val">.ps</EM>  &mdash; output file will
                            be in Postscript format.
                            </LI><BR>
                       <LI> <EM class="val">.gif</EM> &mdash; output file will
                            be in gif format.
                            </LI><BR>
                       <LI> <EM class="val">.txt</EM> &mdash; output file will
                            be in plain ascii format. An ascii table will be
                            generated instead of a figure.
                            </LI><BR>
                   </UL>
                   <P>
                   Unrecognized extension is treated as Postscript.
                   </LI><P>

              <LI> <EM class="com">-color</EM> &mdash; the color index of the 
                   contour map according to DiaGI in a range [-1, 32]. Color 
                   index <EM class="val">-1</EM> indicates the 
                   color of the plot the plot will be selected in 
                   accordance with the observing frequency.
                   Color index 0 means black. Program diagi_dec (part of 
                   petools) shows the color table for codes in the range 
                   [1, 32]. By default, color index is <EM class="val">-1</EM>, 
                   i.e. is selected automatically based on observing frequency.
                   </LI><P>

              <LI> <EM class="com">-size</EM> &mdash; the image size, one of
                   <P>
                   <UL>
                        <LI> <EM class="val">1</EM> &mdash; 45x45 mm   </LI><BR>
                        <LI> <EM class="val">2</EM> &mdash; 80x80 mm   </LI><BR>
                        <LI> <EM class="val">3</EM> &mdash; 160x160 mm </LI><BR>
                        <LI> <EM class="val">4</EM> &mdash; 270x270 mm </LI><BR>
                   </UL>
                   Fonts and line width are scaled in order to fit the
                   sizes above. By default, image size is <EM class="val">3</EM>,
                   i.e. 160x160 mm.
                   </LI><P>

              <LI> <EM class="com">-color</EM> &mdash; the color index of the 
                   contour map according to DiaGI in a range [-1, 32]. Color 
                   index <EM class="val">-1</EM> indicates the 
                   color of the plot the plot will be selected in 
                   accordance with the observing frequency.
                   Color index 0 means black. Program diagi_dec (part of 
                   petools) shows the color table for codes in the range 
                   [1, 32]. By default, color index is <EM class="val">-1</EM>, 
                   i.e. is selected automatically based on observing frequency.
                   </LI><P>

              <LI> <EM class="com">-gap</EM> &mdash; the maximum gap between
                   observations to consider them to belonging to one scan.
                   Units: sec.
                   </LI><P>

              <LI> <EM class="com">-wei</EM> &mdash; to use 
                   (<EM class="val">T</EM>) or not to use 
                   (<EM class="val">F</EM>) weights when compute scan averaged 
                   visibilities.
                   </LI><P>

              <LI> <EM class="com">-cutoff_err</EM> &mdash; the cutoff for
                   discarding points with excessive scatter. The points with 
                   the normalized statistical uncertainties determined
                   as <TT>Err(Amp)/Amp</TT> exceeding this parameter are 
                   flagged out and removed from computations. Here 
                   <TT>Err(Amp)</TT> is the statistical error of the 
                   coherently averaged amplitude determined on the basis of 
                   the scatter with respect to average and <TT>Amp</TT> 
                   is the averaged amplitude. 
                   </LI><P>

              <LI> <EM class="com">-auto</EM> &mdash; auto-detection of the 
                   direction of minimal scatter. If this options is not set
                   up (default), plot of calibrated amplitude versus 
                   baseline length will be generated. If this option is set,
                   then a plot of the averaged fringe amplitude versus the
                   length of the baseline projection to the direction which 
                   makes the scatter of the amplitude with respect to 
                   a smoothed curve minimal.
                   </LI><P>

          </UL>
          </LI><P>

     <LI> <TT><B> fits_to_uvplot  </B></TT> &mdash; utility for generation a plot
          of baseline vector projection to the source tangential plain (so-called
          uvplot). Visibilities are averaged over a scan. Units are wavelengths.
          <P>

          Usage:
<PRE>
          fits_to_uvplot [-o output_file] [-size code] [-color code] uva_fits_file
</PRE>

          A mandatory argument is map file in FITS-UVA or FITS-UVS format. Options:
          <P>
          <UL>
             <LI> <EM class="com">-o</EM> &mdash; the  output file. 
                   <EM class="val">XW</EM> means display.
                   If omitted, <EM class="val">XW</EM> is assumed. 
                   Supported extensions:
                   <P>
 
                   <UL>
                       <LI> <EM class="val">.ps</EM>  &mdash; output file will
                            be in Postscript format.
                            </LI><BR>
                       <LI> <EM class="val">.gif</EM> &mdash; output file will
                            be in gif format.
                            </LI><BR>
                       <LI> <EM class="val">.txt</EM> &mdash; output file will
                            be in plain ascii format. An ascii table will be
                            generated instead of a figure.
                            </LI><BR>
                   </UL>
                   <P>
                   Unrecognized extension is treated as Postscript.
                   </LI><P>

              <LI> <EM class="com">-color</EM> &mdash; the color index of the 
                   contour map according to DiaGI in a range [-1, 32]. Color 
                   index <EM class="val">-1</EM> indicates the 
                   color of the plot the plot will be selected in 
                   accordance with the observing frequency.
                   Color index 0 means black. Program diagi_dec (part of 
                   petools) shows the color table for codes in the range 
                   [1, 32]. By default, color index is <EM class="val">-1</EM>, 
                   i.e. is selected automatically based on observing frequency.
                   </LI><P>

              <LI> <EM class="com">-size</EM> &mdash; the image size, one of
                   <P>
                   <UL>
                        <LI> <EM class="val">1</EM> &mdash; 45x45 mm   </LI><BR>
                        <LI> <EM class="val">2</EM> &mdash; 80x80 mm   </LI><BR>
                        <LI> <EM class="val">3</EM> &mdash; 160x160 mm </LI><BR>
                        <LI> <EM class="val">4</EM> &mdash; 270x270 mm </LI><BR>
                   </UL>
                   Fonts and line width are scaled in order to fit the
                   sizes above. By default, image size is <EM class="val">3</EM>,
                   i.e. 160x160 mm.
                   </LI><P>
          </UL>
          </LI><P>

     <LI> <TT><B> fits_to_cfd </B></TT> &mdash; utility for generation a table
          of median correlated flux densities at three ranges of baseline 
          projection lengths. The table has two rows: a header and the 
          body of the table.
          <P>

          Usage:
<PRE>
          fits_to_cfd [-help] [-o output_file] [-wei T|F] [-cutoff_err value] fits_vis_file fits_map_file
</PRE>
          <P>
          Mandatory arguments are the file with self-calibrated visibilities 
          in FITS-UVS format and image in FITS-MAP format. Options:
          <P>
          <UL>
             <LI> <EM class="com">-o</EM> &mdash; the  output file. 
                  If omitted, the table is printed in stdout, i.e. in the 
                  screen.
                   </LI><P>

              <LI> <EM class="com">-wei</EM> &mdash; to use 
                   (<EM class="val">T</EM>) or not to use 
                   (<EM class="val">F</EM>) weights when compute scan averaged 
                   visibilities.
                   </LI><P>

              <LI> <EM class="com">-cutoff_err</EM> &mdash; the cutoff for
                   discarding points with excessive scatter. The points with 
                   the normalized statistical uncertainties determined
                   as <TT>Err(Amp)/Amp</TT> exceeding this parameter are 
                   flagged out and removed from computations. Here 
                   <TT>Err(Amp)</TT> is the statistical error of the 
                   coherently averaged amplitude determined on the basis of 
                   the scatter with respect to average and <TT>Amp</TT> 
                   is the averaged amplitude. 
                   </LI><P>
         </UL>
</UL>

<P>&nbsp;<P>

<P>
<HR size="1">
<EM>
     This document was prepared by Leonid Petrov
     <BR>
     Last update:    2025.01.07
</EM>
</BODY>
</HTML>
